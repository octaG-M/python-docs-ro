# ARITMETICA IN VIRGULA MOBILA.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Octavian Mustafa <octawian@yahoo.com>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-17 17:56+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ro\n"
"Language-Team: ro <octawian@yahoo.com>\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : (n==0 || (n%100 > 0 && n%100"
" < 20)) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorial/floatingpoint.rst:10
msgid "Floating-Point Arithmetic:  Issues and Limitations"
msgstr "Aritmetică în virgulă mobilă: probleme și limitări"

#: ../../tutorial/floatingpoint.rst:16
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the **decimal** fraction ``0.625`` has "
"value 6/10 + 2/100 + 5/1000, and in the same way the **binary** fraction "
"``0.101`` has value 1/2 + 0/4 + 1/8. These two fractions have identical "
"values, the only real difference being that the first is written in base "
"10 fractional notation, and the second in base 2."
msgstr ""
"Numerele *în virgulă mobilă* (de la englezescul *floating-point*) sunt "
"reprezentate în mașina fizică de calcul ca fracții scrise în baza de "
"numerație 2 (fracții binare). Mai precis, fracția **zecimală** (adică, "
"scrisă în baza de numerație 10) ``0.625`` are valoarea (exprimată cu "
"puteri de exponent negativ ale lui 10) 6/10 + 2/100 + 5/1000 în timp ce, "
"folosind același tip de exprimare cu puteri de exponent negativ, fracția "
"**binară** ``0.101`` are valoarea 1/2 + 0/4 + 1/8. Acestor două fracții "
"le corespunde, dpdv. numeric, aceeași valoare, singura deosebire dintre "
"ele fiind aceea că prima a fost scrisă cu "
"`notații fracționare <https://en.wikipedia.org/wiki/Decimal>`_ ale bazei "
"de numerație 10 pe când cea de-a doua cu notații ale bazei de "
"numerație 2."

#: ../../tutorial/floatingpoint.rst:23
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal "
"floating-point numbers you enter are only approximated by the binary "
"floating-point numbers actually stored in the machine."
msgstr ""
"Din păcate, cele mai multe fracții zecimale nu pot fi reprezentate exact "
"sub formă de fracții binare. O consecință a acestui fapt este că, "
"în general, numerele zecimale în virgulă mobilă pe care le tastați sunt "
"doar aproximații ale numerelor binare în virgulă mobilă care vor fi "
"stocate în mașina de calcul."

#: ../../tutorial/floatingpoint.rst:28
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"Dificultatea este mai ușor de înțeles dacă o abordăm pornind din baza 10. "
"Să luăm în considerare fracția 1/3. O putem aproxima ca fracție în baza "
"10 ::"

#: ../../tutorial/floatingpoint.rst:31
msgid "0.3"
msgstr "0.3"

#: ../../tutorial/floatingpoint.rst:33 ../../tutorial/floatingpoint.rst:37
msgid "or, better, ::"
msgstr "sau, și mai bine, ::"

#: ../../tutorial/floatingpoint.rst:35
msgid "0.33"
msgstr "0.33"

#: ../../tutorial/floatingpoint.rst:39
msgid "0.333"
msgstr "0.333"

#: ../../tutorial/floatingpoint.rst:41
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"șamd. Oricât de multe cifre ne-am strădui să tastăm, rezultatul nu va fi "
"niciodată exact 1/3, chiar dacă vom ajunge la aproximații tot mai bune "
"ale lui 1/3."

#: ../../tutorial/floatingpoint.rst:45
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, "
"the decimal value 0.1 cannot be represented exactly as a base 2 fraction."
"  In base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"La fel, oricât de multe cifre în baza de numerație 2 ne-am strădui "
"să întrebuințăm, valoarea zecimală 0.1 nu va putea fi reprezentată exact "
"ca fracție în baza 2. Pentru că, în baza 2, 1/10 este fracția (`periodică "
"mixtă <https://en.wikipedia.org/wiki/Repeating_decimal>`_) cu număr "
"infinit de cifre la dreapta punctului ::"

#: ../../tutorial/floatingpoint.rst:49
msgid "0.0001100110011001100110011001100110011001100110011..."
msgstr ""

#: ../../tutorial/floatingpoint.rst:51
msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most"
" machines today, floats are approximated using a binary fraction with the"
" numerator using the first 53 bits starting with the most significant bit"
" and with the denominator as a power of two.  In the case of 1/10, the "
"binary fraction is ``3602879701896397 / 2 ** 55`` which is close to but "
"not exactly equal to the true value of 1/10."
msgstr ""
"Dacă de oprim, din tastat, după indiferent câți biți (cifre binare), tot "
"ce obținem este o aproximație. Pe majoritatea mașinilor de calcul din "
"zilele noastre, numerele în virgulă mobilă (în englezește, ca jargon, ele "
"sunt denumite *float*-uri) sunt aproximate folosind o fracție binară al "
"cărei `numărător <https://en.wikipedia.org/wiki/Fraction>`_ "
"utilizează primii 53 de biți, începând cu bitul cel mai semnificativ, "
"iar al cărei numitor este o putere a lui 2.  În cazul lui 1/10, fracția "
"binară este ``3602879701896397 / 2 ** 55``, adică foarte aproape de "
"valoarea exactă a lui 1/10 însă nu chiar egală cu ea."

#: ../../tutorial/floatingpoint.rst:58
msgid ""
"Many users are not aware of the approximation because of the way values "
"are displayed.  Python only prints a decimal approximation to the true "
"decimal value of the binary approximation stored by the machine.  On most"
" machines, if Python were to print the true decimal value of the binary "
"approximation stored for 0.1, it would have to display::"
msgstr ""
"Mulți utilizatori nu sesizează aproximația datorită modului în care "
"valorile numerice sunt afișate. Astfel, Python-ul va printa doar o "
"aproximație zecimală a valorii zecimale precise pe care o are "
"aproximarea binară stocată în mașina de calcul. Pe cele mai multe din "
"mașinile de calcul, dacă ar trebui să afișeze valoarea zecimală precisă "
"a aproximării binare stocate a lui 0.1, atunci Python-ul ar avea de "
"afișat::"

#: ../../tutorial/floatingpoint.rst:64
msgid ""
">>> 0.1\n"
"0.1000000000000000055511151231257827021181583404541015625"
msgstr ""
">>> 0.1\n"
"0.1000000000000000055511151231257827021181583404541015625"

#: ../../tutorial/floatingpoint.rst:67
msgid ""
"That is more digits than most people find useful, so Python keeps the "
"number of digits manageable by displaying a rounded value instead:"
msgstr ""
"Dat fiind că au apărut mai multe cifre decât le sunt de folos majorității "
"utilizatorilor, Python-ul menține numărul cifrelor la valori ușor de "
"manageriat afișând, în loc de cele de mai sus, o valoare rotunjită::"

#: ../../tutorial/floatingpoint.rst:70
msgid ""
">>> 1 / 10\n"
"0.1"
msgstr ""
">>> 1 / 10\n"
"0.1"

#: ../../tutorial/floatingpoint.rst:75
msgid ""
"Just remember, even though the printed result looks like the exact value "
"of 1/10, the actual stored value is the nearest representable binary "
"fraction."
msgstr ""
"Să reținem, așadar, că, în pofida faptului că rezultatul afișat arată la "
"fel ca valoarea exactă a lui 1/10, valoarea efectiv stocată este cea mai "
"apropiată (de rezultat) fracție binară pe care mașina de calcul o poate "
"reprezenta."

#: ../../tutorial/floatingpoint.rst:78
msgid ""
"Interestingly, there are many different decimal numbers that share the "
"same nearest approximate binary fraction.  For example, the numbers "
"``0.1`` and ``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these "
"decimal values share the same approximation, any one of them could be "
"displayed while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Ca o curiozitate, există mai multe numere zecimale (așadar, diferite) "
"cu aceeași cea mai bună aproximație printr-o fracție binară. De exemplu, "
"numerele ``0.1`` și ``0.10000000000000001``, precum și "
"``0.1000000000000000055511151231257827021181583404541015625`` sunt cu "
"toatele aproximate de ``3602879701896397 / 2 ** 55``. Dat fiind că toate "
"aceste valori zecimale au aceeași aproximație, oricare din ele ar putea "
"fi afișată, atunci când se cere, păstrându-se "
"`invariantul <https://en.wikipedia.org/wiki/Class_invariant>`_ "
"``eval(repr(x)) == x``."

#: ../../tutorial/floatingpoint.rst:86
msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose "
"the shortest of these and simply display ``0.1``."
msgstr ""
"În trecut, funcția predefinită a Python-ului :func:`repr` ar fi ales "
"numărul cu 17 cifre semnificative, și anume pe ``0.10000000000000001``. "
"În zilele noastre, începând cu Python 3.1, Python-ul este capabil (pe "
"majoritatea mașinilor de calcul)  să aleagă numărul cel mai scurt și să "
"afișeze, pur și simplu, ``0.1``."

#: ../../tutorial/floatingpoint.rst:91
msgid ""
"Note that this is in the very nature of binary floating point: this is "
"not a bug in Python, and it is not a bug in your code either.  You'll see"
" the same kind of thing in all languages that support your hardware's "
"floating-point arithmetic (although some languages may not *display* the "
"difference by default, or in all output modes)."
msgstr ""
"Rețineți, deci, că situația descrisă mai sus ține de însăși natura "
"numerelor binare în virgulă mobilă: cu alte cuvinte, ea nu este o eroare "
"(de la englezescul *bug*) a Python-ului și nici o eroare a codului scris "
"de dumneavoastră. Această complicație poate fi întâlnită în toate "
"limbajele de programare care suportă aritmetica în virgulă mobilă a "
"mașinii fizice de calcul (chiar dacă unele limbaje ar putea să nu "
"*publice* diferențele în mod implicit, și nici în toate modurile de "
"afișare)."

#: ../../tutorial/floatingpoint.rst:97
msgid ""
"For more pleasant output, you may wish to use string formatting to "
"produce a limited number of significant digits:"
msgstr ""
"Pentru o afișare plăcută ochiului, ați putea utiliza șirurile de "
"formatare ca să produceți un număr restrâns de cifre semnificative:"

#: ../../tutorial/floatingpoint.rst:100
msgid ""
">>> format(math.pi, '.12g')  # give 12 significant digits\n"
"'3.14159265359'\n"
"\n"
">>> format(math.pi, '.2f')   # give 2 digits after the point\n"
"'3.14'\n"
"\n"
">>> repr(math.pi)\n"
"'3.141592653589793'"
msgstr ""
">>> format(math.pi, '.12g')  # printează 12 cifre semnificative\n"
"'3.14159265359'\n"
"\n"
">>> format(math.pi, '.2f')   # printează 2 cifre la dreapta punctului\n"
"'3.14'\n"
"\n"
">>> repr(math.pi)\n"
"'3.141592653589793'"

#: ../../tutorial/floatingpoint.rst:111
msgid ""
"It's important to realize that this is, in a real sense, an illusion: "
"you're simply rounding the *display* of the true machine value."
msgstr ""
"Merită să înțelegem că aceasta este, de fapt, o iluzie: noi nu facem "
"decât să rotunjim *afișajul* valorii stocate în mașina de calcul."

#: ../../tutorial/floatingpoint.rst:114
msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly "
"1/10, summing three values of 0.1 may not yield exactly 0.3, either:"
msgstr ""
"Nicio iluzie nu vine de una singură. Astfel, cum  0.1 nu este chiar "
"1/10, nici suma a trei valori ale lui 0.1 nu va da chiar 0.3:"

#: ../../tutorial/floatingpoint.rst:117
msgid ""
">>> 0.1 + 0.1 + 0.1 == 0.3\n"
"False"
msgstr ""
">>> 0.1 + 0.1 + 0.1 == 0.3\n"
"False"

#: ../../tutorial/floatingpoint.rst:122
msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and "
"0.3 cannot get any closer to the exact value of 3/10, then pre-rounding "
"with :func:`round` function cannot help:"
msgstr ""
"De asemeni, cum acest 0.1 nu poate ajunge oricât de aproape de "
"valoarea exactă a lui 1/10 și nici 0.3-ul nu se poate apropia oricât de "
"mult de valoarea exactă a lui 3/10, pre-rotunjirea valorilor bazată pe "
"funcția :func:`round` nu ne va fi de niciun ajutor:"

#: ../../tutorial/floatingpoint.rst:126
msgid ""
">>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\n"
"False"
msgstr ""
">>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\n"
"False"

#: ../../tutorial/floatingpoint.rst:131
msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`math.isclose` function can be useful for comparing inexact "
"values:"
msgstr ""
"Chiar dacă numerele nu se pot apropia oricât de mult de doritele lor "
"valori exacte, totuși, funcția :func:`math.isclose` ne poate fi de "
"folos la compararea de valori inexacte:"

#: ../../tutorial/floatingpoint.rst:134
msgid ""
">>> math.isclose(0.1 + 0.1 + 0.1, 0.3)\n"
"True"
msgstr ""
">>> math.isclose(0.1 + 0.1 + 0.1, 0.3)\n"
"True"

#: ../../tutorial/floatingpoint.rst:139
msgid ""
"Alternatively, the :func:`round` function can be used to compare rough "
"approximations:"
msgstr ""
"Ca alternativă, funcția :func:`round` este utilă la compararea unor "
"aproximații grosiere:"

#: ../../tutorial/floatingpoint.rst:142
msgid ""
">>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\n"
"True"
msgstr ""
">>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\n"
"True"

#: ../../tutorial/floatingpoint.rst:147
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `Examples of Floating Point "
"Problems <https://jvns.ca/blog/2023/01/13/examples-of-floating-point-"
"problems/>`_ for a pleasant summary of how binary floating point works "
"and the kinds of problems commonly encountered in practice.  Also see "
"`The Perils of Floating Point "
"<http://www.indowsway.com/floatingpoint.htm>`_ for a more complete "
"account of other common surprises."
msgstr ""
"Aritmetica binară în virgulă mobilă este plină de surprize de acest "
"fel. Dificultatea privitoare la \"0.1\" va fi explicată detaliat mai "
"jos, în secțiunea \"Erori de reprezentare\". Vedeți "
"`Exemple de complicații în virgulă mobilă "
"<https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/>`_ "
"pentru un sumar captivant al modului de funcționare al operațiilor în "
"virgulă mobilă și al tipurilor de dificultăți întâlnite frecvent în "
"practică. Vedeți, de asemeni, `Pericolele virgulei mobile "
"<http://www.indowsway.com/floatingpoint.htm>`_ pentru o dare de seamă și "
"mai cuprinzătoare a altor suprize des întâlnite."

#: ../../tutorial/floatingpoint.rst:156
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't "
"be unduly wary of floating point!  The errors in Python float operations "
"are inherited from the floating-point hardware, and on most machines are "
"on the order of no more than 1 part in 2\\*\\*53 per operation.  That's "
"more than adequate for most tasks, but you do need to keep in mind that "
"it's not decimal arithmetic and that every float operation can suffer a "
"new rounding error."
msgstr ""
"Și, după cum se spune la finalul acestui din urmă material, \"nu există "
"răspunsuri simple.\" Însă nu vă lăsați speriați prea ușor de virgula "
"mobilă! Erorile produse de operațiile în virgulă mobilă din Python sunt "
"moștenite de la arhitectura de calcul în virgulă mobilă a mașinii de "
"calcul iar pe cele mai multe din mașini erorile nu vor depăși ordinul "
"de 1 pe 2\\*\\*53 per operație. Aceasta este mai mult decât potrivit "
"pentru majoritatea activităților, dar nu scăpați din vedere că nu lucrați "
"cu aritmetică zecimală și nici că orice operație în virgulă mobilă poate "
"suferi de propria sa eroare de rotunjire."

#: ../../tutorial/floatingpoint.rst:163
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply "
"round the display of your final results to the number of decimal digits "
"you expect. :func:`str` usually suffices, and for finer control see the "
":meth:`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Deși cazurile patologice vor continua să existe, utilizările obișnuite "
"ale aritmeticii în virgulă mobilă vor conduce la rezultatul scontat "
"atunci când veți rotunji afișarea rezultatelor finale la numărul de "
"zecimale dorit. Chiar dacă funcția :func:`str` este, de obicei, "
"suficientă, pentru un control mai fin al printării consultați "
"specificatorii de format ai metodei :meth:`str.format` din "
":ref:`formatstrings`."

#: ../../tutorial/floatingpoint.rst:169
msgid ""
"For use cases which require exact decimal representation, try using the "
":mod:`decimal` module which implements decimal arithmetic suitable for "
"accounting applications and high-precision applications."
msgstr ""
"Pentru cazurile de întrebuințare care au nevoie de reprezentări zecimale "
"exacte, vă recomandăm să folosiți modulul :mod:`decimal` în care este "
"implementată o aritmetică zecimală potrivită atât pentru aplicațiile de "
"contabilitate cât și pentru cele de înaltă precizie (numerică)."

#: ../../tutorial/floatingpoint.rst:173
msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` "
"module which implements arithmetic based on rational numbers (so the "
"numbers like 1/3 can be represented exactly)."
msgstr ""
"Altă formă de aritmetică exactă este oferită de modulul :mod:`fractions` "
"care implementează o aritmetică bazată pe numere "
"`raționale <https://en.wikipedia.org/wiki/Rational_number>`_ " 
"(astfel încât numerele de forma 1/3 să fie reprezentate exact)."

#: ../../tutorial/floatingpoint.rst:177
msgid ""
"If you are a heavy user of floating-point operations you should take a "
"look at the NumPy package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See "
"<https://scipy.org>."
msgstr ""
"În cazul în care sunteți un utilizator asiduu al operațiilor în virgulă "
"mobilă atunci n-ar strica să aruncați o privire asupra pachetului NumPy "
"ori asupra oricăruia din numeroasele pachete de calcul matematic și "
"statistică oferite de către proiectul SciPy. Vezi <https://scipy.org>."

#: ../../tutorial/floatingpoint.rst:181
msgid ""
"Python provides tools that may help on those rare occasions when you "
"really *do* want to know the exact value of a float.  The "
":meth:`float.as_integer_ratio` method expresses the value of a float as a"
" fraction:"
msgstr ""
"Python-ul vă pune la dispoziție unelte software care vă vor putea fi de "
"folos în rarele ocazii în care vă va interesa *cu adevărat* valoarea "
"exactă a unui număr în virgulă mobilă. Metoda "
":meth:`float.as_integer_ratio` exprimă valoarea unui număr în virgulă "
"mobilă sub formă de fracție:"

#: ../../tutorial/floatingpoint.rst:186
msgid ""
">>> x = 3.14159\n"
">>> x.as_integer_ratio()\n"
"(3537115888337719, 1125899906842624)"
msgstr ""
">>> x = 3.14159\n"
">>> x.as_integer_ratio()\n"
"(3537115888337719, 1125899906842624)"

#: ../../tutorial/floatingpoint.rst:192
msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the "
"original value:"
msgstr ""
"Deoarece fracția este exactă, o putem folosi pentru a reconstitui, fără "
"pierderi, valoarea originală:"

#: ../../tutorial/floatingpoint.rst:195
msgid ""
">>> x == 3537115888337719 / 1125899906842624\n"
"True"
msgstr ""
">>> x == 3537115888337719 / 1125899906842624\n"
"True"

#: ../../tutorial/floatingpoint.rst:200
msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer:"
msgstr ""
"Metoda :meth:`float.hex` exprimă float-urile în format hexazecimal (adică, "
"în baza de numerație 16), returnând, și ea, exact valoarea stocată în "
"calculatorul dumneavoastră:"

#: ../../tutorial/floatingpoint.rst:203
msgid ""
">>> x.hex()\n"
"'0x1.921f9f01b866ep+1'"
msgstr ""
">>> x.hex()\n"
"'0x1.921f9f01b866ep+1'"

#: ../../tutorial/floatingpoint.rst:208
msgid ""
"This precise hexadecimal representation can be used to reconstruct the "
"float value exactly:"
msgstr ""
"Această reprezentare hexazecimală precisă poate fi întrebuințată la "
"reconstrucția fără pierderi a valorii float-ului:"

#: ../../tutorial/floatingpoint.rst:211
msgid ""
">>> x == float.fromhex('0x1.921f9f01b866ep+1')\n"
"True"
msgstr ""
">>> x == float.fromhex('0x1.921f9f01b866ep+1')\n"
"True"

#: ../../tutorial/floatingpoint.rst:216
msgid ""
"Since the representation is exact, it is useful for reliably porting "
"values across different versions of Python (platform independence) and "
"exchanging data with other languages that support the same format (such "
"as Java and C99)."
msgstr ""
"Fiind o reprezentare exactă, ea este utilă la *portarea* (transportul, de "
"la englezescul *porting*) în siguranță a valorilor între diferitele "
"versiuni de Python (oferind, așadar, independența de platforma de "
"calcul) precum și la schimbul de valori dintre Python și alte limbaje "
"de programare care suportă acest format (cum sunt Java și C99)."

#: ../../tutorial/floatingpoint.rst:220
msgid ""
"Another helpful tool is the :func:`sum` function which helps mitigate "
"loss-of-precision during summation.  It uses extended precision for "
"intermediate rounding steps as values are added onto a running total. "
"That can make a difference in overall accuracy so that the errors do not "
"accumulate to the point where they affect the final total:"
msgstr ""
"Altă unealtă software folositoare este funcția :func:`sum` care știe cum "
"să amelioreze pierderile de precizie de pe parcursul sumărilor. Ea se "
"bazează pe precizia extinsă la rotunjirile pe care le efectuează în pașii "
"de calcul intermediari în care valori succesive (termenii sumei) sunt "
"acumulate într-o valoare totală (`totalul cumulativ "
"<https://en.wikipedia.org/wiki/Running_total>`_). Această tehnică va conta "
"pentru acuratețea generală, împiedicând acumularea erorilor până la o "
"valoare care să afecteze *totalul general*:"

#: ../../tutorial/floatingpoint.rst:226
msgid ""
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False\n"
">>> sum([0.1] * 10) == 1.0\n"
"True"
msgstr ""
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False\n"
">>> sum([0.1] * 10) == 1.0\n"
"True"

#: ../../tutorial/floatingpoint.rst:233
msgid ""
"The :func:`math.fsum` goes further and tracks all of the \"lost digits\" "
"as values are added onto a running total so that the result has only a "
"single rounding.  This is slower than :func:`sum` but will be more "
"accurate in uncommon cases where large magnitude inputs mostly cancel "
"each other out leaving a final sum near zero:"
msgstr ""
"Funcția :func:`math.fsum` merge chiar mai departe și detectează toate "
"\"cifrele pierdute\" de pe parcursul adăugirilor la *totalul cumulativ*, "
"ceea ce conduce la o singură rotunjire a rezultatului final. Deși este "
"mai înceată decât funcția :func:`sum`, ea se dovedește mai precisă în "
"situațiile-limită, acolo unde date de valori mari se anihilează unele pe "
"altele în calcul făcând ca *grand totalul* să fie aproape zero:"

#: ../../tutorial/floatingpoint.rst:239
msgid ""
">>> arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,"
"\n"
"...        -143401161400469.7, 266262841.31058735, -0.003244936839808227]"
"\n"
">>> float(sum(map(Fraction, arr)))   # Exact summation with single "
"rounding\n"
"8.042173697819788e-13\n"
">>> math.fsum(arr)                   # Single rounding\n"
"8.042173697819788e-13\n"
">>> sum(arr)                         # Multiple roundings in extended "
"precision\n"
"8.042178034628478e-13\n"
">>> total = 0.0\n"
">>> for x in arr:\n"
"...     total += x                   # Multiple roundings in standard "
"precision\n"
"...\n"
">>> total                            # Straight addition has no correct "
"digits!\n"
"-0.0051575902860057365"
msgstr ""
">>> valori_mari = [-0.10430216751806065, -266310978.67179024, "
"143401161448607.16,\n"
"...                -143401161400469.7, 266262841.31058735, "
"-0.003244936839808227]\n"
">>> float(sum(map(Fraction, valori_mari)))   # Sumare exactă cu o singură "
"rotunjire\n"
"8.042173697819788e-13\n"
">>> math.fsum(valori_mari)                   # O singură rotunjire\n"
"8.042173697819788e-13\n"
">>> sum(valori_mari)                         # Rotunjiri multiple în precizie "
"extinsă\n"
"8.042178034628478e-13\n"
">>> totalul = 0.0\n"
">>> for x in valori_mari:\n"
"...     totalul += x                         # Rotunjiri multiple în precizie "
"obișnuită\n"
"...\n"
">>>                                          # Adunarea directă nu conduce la nici\n"
">>> totalul                                  # măcar o cifră corectă!\n"
"-0.0051575902860057365"

#: ../../tutorial/floatingpoint.rst:260
msgid "Representation Error"
msgstr "Erori de reprezentare"

#: ../../tutorial/floatingpoint.rst:262
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you "
"can perform an exact analysis of cases like this yourself.  Basic "
"familiarity with binary floating-point representation is assumed."
msgstr ""
"Secțiunea de față se ocupă de exemplul \"0.1\" în detaliu și vă "
"prezintă ce aveți de făcut pentru a realiza o asemenea analiză de "
"caz riguroasă chiar dumneavoastră. Presupunem că dispuneți de o "
"minimă familiaritate cu reprezentările binare în virgulă mobilă ale "
"numerelor."

#: ../../tutorial/floatingpoint.rst:266
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually)"
" decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number "
"you expect."
msgstr ""
":dfn:`Eroarea de reprezentare` se referă la faptul că anumite (de fapt, "
"majoritatea lor) fracții zecimale nu pot fi reprezentate exact ca fracții "
"binare (în baza 2). Această situație este motivul fundamental pentru care "
"Python-ul (ori Perl-ul, C-ul, C++-ul, Java-ul, Fortran-ul și diverse alte "
"limbaje de programare) nu afișează, în multe cazuri, exact numărul "
"zecimal la care v-ați fi așteptat."

#: ../../tutorial/floatingpoint.rst:271
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction.  "
"Since at least 2000, almost all machines use IEEE 754 binary floating-"
"point arithmetic, and almost all platforms map Python floats to IEEE 754 "
"binary64 \"double precision\" values.  IEEE 754 binary64 values contain "
"53 bits of precision, so on input the computer strives to convert 0.1 to "
"the closest fraction it can of the form *J*/2**\\ *N* where *J* is an "
"integer containing exactly 53 bits. Rewriting ::"
msgstr ""
"De ce asta? Pentru că 1/10 nu este reprezentabil exact ca fracție "
"binară. Încă din anul 2000, cel puțin, aproape toate mașinile de calcul "
"folosesc aritmetica binară în virgulă mobilă a standardului IEEE 754 iar "
"majoritatea platformelor de calcul mapează float-urile din Python pe "
"valorile binare, date în dubla precizie pe 64 de biți (*binary64*) a "
"standardului IEEE 754. Valorile binary64 ale lui IEEE 754 conțin 53 de "
"biți de precizie, astfel că, atunci când îl primește pe 0.1 ca dată de "
"intrare, calculatorul va încerca să-l convertească în cea mai apropiată "
"ca valoare fracție de forma *J*/2**\\ *N*, unde *J* este un număr "
"întreg de exact 53 de biți. Rescriind relația ::"

#: ../../tutorial/floatingpoint.rst:280
msgid "1 / 10 ~= J / (2**N)"
msgstr "1 / 10 ~= J / (2**N)"

#: ../../tutorial/floatingpoint.rst:282
msgid "as ::"
msgstr "drept ::"

#: ../../tutorial/floatingpoint.rst:284
msgid "J ~= 2**N / 10"
msgstr "J ~= 2**N / 10"

#: ../../tutorial/floatingpoint.rst:286
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56:"
msgstr ""
"și ținând seama de faptul că *J* are exact 53 de biți (adică, este "
"``>= 2**52`` dar ``< 2**53``), deducem că valoarea cea mai bună pentru "
"*N* este 56:"

#: ../../tutorial/floatingpoint.rst:289
msgid ""
">>> 2**52 <=  2**56 // 10  < 2**53\n"
"True"
msgstr ""
">>> 2**52 <=  2**56 // 10  < 2**53\n"
"True"

#: ../../tutorial/floatingpoint.rst:294
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 "
"bits.  The best possible value for *J* is then that quotient rounded:"
msgstr ""
"Cu alte cuvinte, 56 este singura valoare a lui *N* pentru care *J* "
"va avea exact 53 de biți. Astfel, cea mai bună alegere a lui *J* va fi "
"cea dată de rotunjirea câtului:"

#: ../../tutorial/floatingpoint.rst:297
msgid ""
">>> q, r = divmod(2**56, 10)\n"
">>> r\n"
"6"
msgstr ""
">>> q, r = divmod(2**56, 10)\n"
">>> r\n"
"6"

#: ../../tutorial/floatingpoint.rst:303
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up:"
msgstr ""
"Dat fiind că restul (la împărțirea cu 10) este mai mare decât jumătate "
"din 10, cea mai bună aproximație este cea obținută cu rotunjire prin "
"adaos:"

#: ../../tutorial/floatingpoint.rst:306
msgid ""
">>> q+1\n"
"7205759403792794"
msgstr ""
">>> q+1\n"
"7205759403792794"

#: ../../tutorial/floatingpoint.rst:313
msgid ""
"Therefore the best possible approximation to 1/10 in IEEE 754 double "
"precision is::"
msgstr ""
"Așadar, cea mai bună aproximație a lui 1/10 în dubla precizie oferită de "
"standardul IEEE 754 este::"

#: ../../tutorial/floatingpoint.rst:316
msgid "7205759403792794 / 2 ** 56"
msgstr "7205759403792794 / 2 ** 56"

#: ../../tutorial/floatingpoint.rst:318
msgid ""
"Dividing both the numerator and denominator by two reduces the fraction "
"to::"
msgstr ""
"Împărțind atât numărătorul cât și numitorul la 2 (adică, simplificând "
"fracția cu 2), fracția devine::"

#: ../../tutorial/floatingpoint.rst:320
msgid "3602879701896397 / 2 ** 55"
msgstr "3602879701896397 / 2 ** 55"

#: ../../tutorial/floatingpoint.rst:322
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit"
" smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Remarcați faptul că, deoarece am realizat o rotunjire prin adaos, această "
"fracție este puțin mai mare decât 1/10; dacă nu am fi folosit adaosul, "
"atunci câtul ar fi fost puțin mai mic decât 1/10. Însă, în niciun caz, nu "
"am fi ajuns *exact* la 1/10!"

#: ../../tutorial/floatingpoint.rst:326
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best IEEE 754 double approximation it can get:"
msgstr ""
"În concluzie, calculatorul nu-l \"vede\" pe 1/10 niciodată : tot ce poate "
"vedea este exact fracția dată mai sus, ea fiind cea mai bună aproximație "
"în dublă precizie pe care o poate construi urmând standardul IEEE 754:"

#: ../../tutorial/floatingpoint.rst:329
msgid ""
">>> 0.1 * 2 ** 55\n"
"3602879701896397.0"
msgstr ""
">>> 0.1 * 2 ** 55\n"
"3602879701896397.0"

#: ../../tutorial/floatingpoint.rst:334
msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to "
"55 decimal digits:"
msgstr ""
"Dacă înmulțim fracția in cauză cu 10\\*\\*55, atunci îi vom vedea valoarea "
"scrisă cu 55 de cifre zecimale:"

#: ../../tutorial/floatingpoint.rst:337
msgid ""
">>> 3602879701896397 * 10 ** 55 // 2 ** 55\n"
"1000000000000000055511151231257827021181583404541015625"
msgstr ""
">>> 3602879701896397 * 10 ** 55 // 2 ** 55\n"
"1000000000000000055511151231257827021181583404541015625"

#: ../../tutorial/floatingpoint.rst:342
msgid ""
"meaning that the exact number stored in the computer is equal to the "
"decimal value 0.1000000000000000055511151231257827021181583404541015625. "
"Instead of displaying the full decimal value, many languages (including "
"older versions of Python), round the result to 17 significant digits:"
msgstr ""
"ceea ce înseamnă că numărul stocat în calculator este egal cu valoarea "
"zecimală 0.1000000000000000055511151231257827021181583404541015625. "
"În loc să afișeze această valoare zecimală în întregime, multe limbaje de "
"programare (și, printre ele, versiunile mai vechi ale Python-ului), o "
"vor rotunji la 17 cifre semnificative:"

#: ../../tutorial/floatingpoint.rst:347
msgid ""
">>> format(0.1, '.17f')\n"
"'0.10000000000000001'"
msgstr ""
">>> format(0.1, '.17f')\n"
"'0.10000000000000001'"

#: ../../tutorial/floatingpoint.rst:352
msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations "
"easy:"
msgstr ""
"Modulele :mod:`fractions` și :mod:`decimal` ușurează aceste calcule:"

#: ../../tutorial/floatingpoint.rst:355
msgid ""
">>> from decimal import Decimal\n"
">>> from fractions import Fraction\n"
"\n"
">>> Fraction.from_float(0.1)\n"
"Fraction(3602879701896397, 36028797018963968)\n"
"\n"
">>> (0.1).as_integer_ratio()\n"
"(3602879701896397, 36028797018963968)\n"
"\n"
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
"\n"
">>> format(Decimal.from_float(0.1), '.17')\n"
"'0.10000000000000001'"
msgstr ""
">>> from decimal import Decimal\n"
">>> from fractions import Fraction\n"
"\n"
">>> Fraction.from_float(0.1)\n"
"Fraction(3602879701896397, 36028797018963968)\n"
"\n"
">>> (0.1).as_integer_ratio()\n"
"(3602879701896397, 36028797018963968)\n"
"\n"
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
"\n"
">>> format(Decimal.from_float(0.1), '.17')\n"
"'0.10000000000000001'"


