# TURUL PE SCURT AL BIBLIOTECII STANDARD --- PARTEA II.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Octavian Mustafa <octawian@yahoo.com>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-17 17:56+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ro\n"
"Language-Team: ro <octawian@yahoo.com>\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : (n==0 || (n%100 > 0 && n%100"
" < 20)) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorial/stdlib2.rst:5
msgid "Brief Tour of the Standard Library --- Part II"
msgstr "Turul pe scurt al bibliotecii standard --- Partea II"

#: ../../tutorial/stdlib2.rst:7
msgid ""
"This second tour covers more advanced modules that support professional "
"programming needs.  These modules rarely occur in small scripts."
msgstr ""
"În partea a doua a turului ne vom referi la module avansate care deservesc "
"nevoile programatorului profesionist. Nu este de așteptat ca astfel de "
"module să apară prea des în scripturile de dimensiuni mici."

#: ../../tutorial/stdlib2.rst:14
msgid "Output Formatting"
msgstr "Formatarea ieșirii"

#: ../../tutorial/stdlib2.rst:16
msgid ""
"The :mod:`reprlib` module provides a version of :func:`repr` customized "
"for abbreviated displays of large or deeply nested containers::"
msgstr ""
"Modulul :mod:`reprlib` ne pune la dispoziție o versiune a funcției "
":func:`repr` adaptată la afișările cu *abrevieri de conținut* "
"atât pentru `containere masive <https://ro.wikipedia.org/wiki/"
"Cel_mai_lung_cuv%C3%A2nt_%C3%AEn_rom%C3%A2n%C4%83>`_ "
"cât și pentru containerele cu imbricări multiple (stratificate)::"

#: ../../tutorial/stdlib2.rst:19
#, python-brace-format
msgid ""
">>> import reprlib\n"
">>> reprlib.repr(set('supercalifragilisticexpialidocious'))\n"
"\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\""
msgstr ""
">>> import reprlib\n"
">>> reprlib.repr(set('pneumonoultramicroscopicsilicovolcaniconioza'))\n"
"\"{'a', 'c', 'e', 'i', 'l', 'm', ...}\""

#: ../../tutorial/stdlib2.rst:23
msgid ""
"The :mod:`pprint` module offers more sophisticated control over printing "
"both built-in and user defined objects in a way that is readable by the "
"interpreter. When the result is longer than one line, the \"pretty "
"printer\" adds line breaks and indentation to more clearly reveal data "
"structure::"
msgstr ""
"Modulul :mod:`pprint` oferă un control (încă și) mai sofisticat asupra "
"afișării atât a obiectelor predefinite cât și a celor definite de "
"utilizator, control care le face pe acestea lizibile pentru interpretor. "
"În caz că rezultatul va depăși lungimea unui rând, \"tipograful îngrijit\" "
"(sau *realizatorul de aranjări sugestive*; de la englezescul `pretty "
"printer <https://en.wikipedia.org/wiki/Pretty-printing>`_) îi va adăuga "
"caractere sfârșit-de-rând și indentări pentru a revela cu claritate "
"structura datelor (ce trebuie afișate)::"

#: ../../tutorial/stdlib2.rst:28
msgid ""
">>> import pprint\n"
">>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n"
"...     'yellow'], 'blue']]]\n"
"...\n"
">>> pprint.pprint(t, width=30)\n"
"[[[['black', 'cyan'],\n"
"   'white',\n"
"   ['green', 'red']],\n"
"  [['magenta', 'yellow'],\n"
"   'blue']]]"
msgstr ""
">>> import pprint\n"
">>> paletă = [[[['negru', 'turcoaz'], 'alb', ['verde',\n"
"...           'roșu']], [['fucsia', 'galben'], 'albastru']]]\n"
"...\n"
">>> pprint.pprint(paletă, width=30)\n"
"[[[['negru', 'turcoaz'],\n"
"   'alb',\n"
"   ['verde', 'roșu']],\n"
"  [['fucsia', 'galben'],\n"
"   'albastru']]]"

#: ../../tutorial/stdlib2.rst:39
msgid ""
"The :mod:`textwrap` module formats paragraphs of text to fit a given "
"screen width::"
msgstr ""
"Modulul :mod:`textwrap` formatează paragrafele de text pentru ca acestea "
"să încapă pe un ecran (de terminal) cu lungimea dată::"

#: ../../tutorial/stdlib2.rst:42
msgid ""
">>> import textwrap\n"
">>> doc = \"\"\"The wrap() method is just like fill() except that it "
"returns\n"
"... a list of strings instead of one big string with newlines to separate"
"\n"
"... the wrapped lines.\"\"\"\n"
"...\n"
">>> print(textwrap.fill(doc, width=40))\n"
"The wrap() method is just like fill()\n"
"except that it returns a list of strings\n"
"instead of one big string with newlines\n"
"to separate the wrapped lines."
msgstr ""
">>> import textwrap\n"
">>> documentul = \"\"\"Metoda wrap() este la fel cu metoda fill() doar că "
"returnează\n"
"... o listă de șiruri de caractere în locul unui șir de caractere foarte "
"lung care\n"
"... conține caractere sfârșit-de-rând pentru a putea să delimiteze "
"rândurile\n"
"... în care a fost împărțit.\"\"\"\n"
"...\n"
">>> print(textwrap.fill(documentul, width=40))\n"
"Metoda wrap() este la fel cu metoda\n"
"fill() doar că returnează o listă de\n"
"șiruri de caractere în locul unui șir de\n"
"caractere foarte lung care conține\n"
"caractere sfârșit-de-rând pentru a putea\n"
"să delimiteze rândurile în care a fost\n"
"împărțit."

#: ../../tutorial/stdlib2.rst:53
msgid ""
"The :mod:`locale` module accesses a database of culture specific data "
"formats. The grouping attribute of locale's format function provides a "
"direct way of formatting numbers with group separators::"
msgstr ""
"Modulul :mod:`locale` accesează o bază de date (POSIX) cu formate de date "
"specifice diverselor *culturi*. Atributul de *grupare* al funcției de "
"format din (modulul) *locale* ne pune la îndemână o modalitate imediată de "
"formatare a numerelor cu ajutorul separatoarelor de grup::"

#: ../../tutorial/stdlib2.rst:57
#, python-format
msgid ""
">>> import locale\n"
">>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n"
"'English_United States.1252'\n"
">>> conv = locale.localeconv()          # get a mapping of conventions\n"
">>> x = 1234567.8\n"
">>> locale.format_string(\"%d\", x, grouping=True)\n"
"'1,234,567'\n"
">>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n"
"...                      conv['frac_digits'], x), grouping=True)\n"
"'$1,234,567.80'"
msgstr ""
">>> import locale\n"
">>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n"
"'English_United States.1252'\n"
">>> # Obțineți o mapare a convențiilor (obiceiurile locale):\n"
">>> convenții = locale.localeconv()\n"
">>> numărul = 1234567.8\n"
">>> locale.format_string(\"%d\", numărul, grouping=True)\n"
"'1,234,567'\n"
">>> locale.format_string(\"%s%.*f\", (convenții['currency_symbol'],\n"
"...                      convenții['frac_digits'], numărul),\n"
"...                      grouping=True)\n"
"'$1,234,567.80'"

#: ../../tutorial/stdlib2.rst:72
msgid "Templating"
msgstr "Folosirea șabloanelor"

#: ../../tutorial/stdlib2.rst:74
msgid ""
"The :mod:`string` module includes a versatile :class:`~string.Template` "
"class with a simplified syntax suitable for editing by end-users.  This "
"allows users to customize their applications without having to alter the "
"application."
msgstr ""
"Modulul :mod:`string` include o clasă :class:`~string.Template` versatilă "
"a cărei sintaxă simplificată o face ușor de întrebuințat de către "
"utilizatori. Cu ajutorul său, aceștia pot să-și personalizeze aplicațiile "
"fără a fi nevoiți să opereze modificări în codul de bază al respectivelor "
"aplicații."

#: ../../tutorial/stdlib2.rst:78
msgid ""
"The format uses placeholder names formed by ``$`` with valid Python "
"identifiers (alphanumeric characters and underscores).  Surrounding the "
"placeholder with braces allows it to be followed by more alphanumeric "
"letters with no intervening spaces.  Writing ``$$`` creates a single "
"escaped ``$``::"
msgstr ""
"Formatul (din șablon) utilizează *nume de înlocuire* construite din "
"identificatori valizi în Python (adică, alcătuiți doar din caractere "
"alfanumerice și din caractere bară jos; atenție, doar caractere ASCII) "
"pe care le prefațăm cu ``$``. Numele de înlocuire se încadrează cu "
"acolade, ceea ce le permite să fie urmate de (și mai multe) litere "
"alfanumerice, însă acestea *fără spații goale* printre ele. Pentru "
"escaparea unui caracter ``$``, el va fi inserat sub forma ``$$``::"

#: ../../tutorial/stdlib2.rst:83
#, python-brace-format
msgid ""
">>> from string import Template\n"
">>> t = Template('${village}folk send $$10 to $cause.')\n"
">>> t.substitute(village='Nottingham', cause='the ditch fund')\n"
"'Nottinghamfolk send $10 to the ditch fund.'"
msgstr ""
">>> from string import Template\n"
">>> șablonul = Template(\"Amice-din-orașul-${localitatea}City, \"\n"
"...                     \"dă și matale $$10 pe $visul_nostru.\")\n"
">>> șablonul.substitute(localitatea='Medgidia',\n"
"...                     visul_nostru='apa gârlei')\n"
"'Amice-din-orașul-MedgidiaCity, dă și matale $10 pe apa gârlei.'"

#: ../../tutorial/stdlib2.rst:88
msgid ""
"The :meth:`~string.Template.substitute` method raises a :exc:`KeyError` "
"when a placeholder is not supplied in a dictionary or a keyword argument."
"  For mail-merge style applications, user supplied data may be incomplete"
" and the :meth:`~string.Template.safe_substitute` method may be more "
"appropriate --- it will leave placeholders unchanged if data is missing::"
msgstr ""
"Metoda :meth:`~string.Template.substitute` ridică o excepție "
":exc:`KeyError` dacă vreun nume de înlocuire nu îi va fi furnizat fie de "
"către un argument de tip dicționar de date fie de un argument cuvânt-cheie. "
"În cazul unor aplicații cu documente construite în stilul "
"`Mail Merge <https://support.microsoft.com/en-gb/topic/how-to-use-the-mail-"
"merge-feature-in-word-to-create-and-to-print-form-letters-that-use-the-"
"data-from-an-excel-worksheet-d8709e29-c106-2348-7e38-13eecc338679>`_ "
"(îmbinare-de-mesaje) survin situații când datele oferite de utilizator "
"rămân incomplete, din care motiv utilizarea metodei "
":meth:`~string.Template.safe_substitute` ar putea fi (mai) potrivită --- "
"căci aceasta nu va modifica numele de înlocuire dacă lipsesc datele "
"corespunzătoare respectivelor nume. Exemplul de mai jos face referire la "
"`episodul cu rândunica <https://montypython.fandom.com/wiki/Swallow>`_ "
"(Monty Python)::"

#: ../../tutorial/stdlib2.rst:94
msgid ""
">>> t = Template('Return the $item to $owner.')\n"
">>> d = dict(item='unladen swallow')\n"
">>> t.substitute(d)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'owner'\n"
">>> t.safe_substitute(d)\n"
"'Return the unladen swallow to $owner.'"
msgstr ""
">>> șablonul = Template('De înapoiat $colet la $expeditor.')\n"
">>> dicționarul = dict(colet='rândunica fără nimica')\n"
">>> șablonul.substitute(dicționarul)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'expeditor'\n"
">>> șablonul.safe_substitute(dicționarul)\n"
"'De înapoiat rândunica fără nimica la $expeditor.'"

#: ../../tutorial/stdlib2.rst:103
msgid ""
"Template subclasses can specify a custom delimiter.  For example, a batch"
" renaming utility for a photo browser may elect to use percent signs for "
"placeholders such as the current date, image sequence number, or file "
"format::"
msgstr ""
"Urmașele clasei *Template* își pot personaliza *delimitatorul*. De exemplu, "
"un script utilitar de redenumire a unor loturi de fotografii, atașat unui "
"album fotografic, poate întrebuința semnul grafic *procent* pe post de "
"caracter de înlocuire pentru șiruri de caractere precum data "
"calendaristică, numărul (de ordine în lot al) fișierului foto, respectiv "
"extensia fișierului::"

#: ../../tutorial/stdlib2.rst:107
#, python-brace-format, python-format
msgid ""
">>> import time, os.path\n"
">>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n"
">>> class BatchRename(Template):\n"
"...     delimiter = '%'\n"
"...\n"
">>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')\n"
"Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f\n"
"\n"
">>> t = BatchRename(fmt)\n"
">>> date = time.strftime('%d%b%y')\n"
">>> for i, filename in enumerate(photofiles):\n"
"...     base, ext = os.path.splitext(filename)\n"
"...     newname = t.substitute(d=date, n=i, f=ext)\n"
"...     print('{0} --> {1}'.format(filename, newname))\n"
"\n"
"img_1074.jpg --> Ashley_0.jpg\n"
"img_1076.jpg --> Ashley_1.jpg\n"
"img_1077.jpg --> Ashley_2.jpg"
msgstr ""
">>> import string, time, os.path\n"
">>> fișiere_foto = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n"
">>> class RedenumeșteLotul(string.Template):\n"
"...     delimiter = '%' # suprascriem atributul delimiter\n"
"...\n"
">>> formatul = input(\"Introduceți stilul redenumirii \"\n"
"...                  \"(%d-data %n-numărul %f-extensia_fișierului):  \")\n"
"Introduceți stilul redenumirii (%d-data %n-numărul %f-extensia_fișierului):"
"  Viorica_%n%f\n"
"\n"
">>> șablonul = RedenumeșteLotul(formatul)\n"
">>> data = time.strftime('%d%b%y')\n"
">>> for i, nume_de_fișier in enumerate(fișiere_foto):\n"
"...     baza, extensia = os.path.splitext(nume_de_fișier)\n"
"...     noul_nume = șablonul.substitute(d=data, n=i, f=extensia)\n"
"...     print('{0} --> {1}'.format(nume_de_fișier, noul_nume))\n"
"\n"
"img_1074.jpg --> Viorica_0.jpg\n"
"img_1076.jpg --> Viorica_1.jpg\n"
"img_1077.jpg --> Viorica_2.jpg"

#: ../../tutorial/stdlib2.rst:126
msgid ""
"Another application for templating is separating program logic from the "
"details of multiple output formats.  This makes it possible to substitute"
" custom templates for XML files, plain text reports, and HTML web "
"reports."
msgstr ""
"Ceea ce face șabloanele atât de utile în practică este chiar caracteristica "
"esențială a acestora, și anume *separarea* logicii unui program de afișarea "
"rezultatelor execuției lui. Astfel, pot fi construite șabloane "
"personalizate pentru introducerea convenabilă a acestor rezultate în "
"fișiere XML, în rapoarte sub formă de text simplu, ori în rapoarte HTML "
"destinate Internetului."

#: ../../tutorial/stdlib2.rst:134
msgid "Working with Binary Data Record Layouts"
msgstr "Lucrul cu machete ale înregistrărilor de date binare"

#: ../../tutorial/stdlib2.rst:136
msgid ""
"The :mod:`struct` module provides :func:`~struct.pack` and "
":func:`~struct.unpack` functions for working with variable length binary "
"record formats.  The following example shows how to loop through header "
"information in a ZIP file without using the :mod:`zipfile` module.  Pack "
"codes ``\"H\"`` and ``\"I\"`` represent two and four byte unsigned "
"numbers respectively.  The ``\"<\"`` indicates that they are standard "
"size and in little-endian byte order::"
msgstr ""
"Modulul :mod:`struct` ne pune la dispoziție funcțiile :func:`~struct.pack` "
"și :func:`~struct.unpack` pentru a putea manipula formate de înregistrări "
"binare de lungimi diverse. Exemplul de mai jos ne arată cum putem parcurge "
"informația din antetul unui fișier ZIP fără a face uz de modulul "
":mod:`zipfile`. Codurile de arhivare (de la englezescul *pack*) ``\"H\"`` "
"și ``\"I\"`` reprezintă numere întregi fără semn (cu lungime) de doi și "
"respectiv de patru octeți. Semnul ``\"<\"`` ne arată că datele au lungime "
"standard și sunt dispuse în formatul de stocare inversat (sau de *memorare "
"inversată*; de la englezescul, ca jargon informatic, *little-endian*)::"

#: ../../tutorial/stdlib2.rst:144
msgid ""
"import struct\n"
"\n"
"with open('myfile.zip', 'rb') as f:\n"
"    data = f.read()\n"
"\n"
"start = 0\n"
"for i in range(3):                      # show the first 3 file headers\n"
"    start += 14\n"
"    fields = struct.unpack('<IIIHH', data[start:start+16])\n"
"    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields\n"
"\n"
"    start += 16\n"
"    filename = data[start:start+filenamesize]\n"
"    start += filenamesize\n"
"    extra = data[start:start+extra_size]\n"
"    print(filename, hex(crc32), comp_size, uncomp_size)\n"
"\n"
"    start += extra_size + comp_size     # skip to the next header"
msgstr ""
">>> import struct\n"
">>> # Fișierul fișierul_meu.zip este arhiva ZIP a (minim) 3 fișiere text:\n"
">>> with open('fișierul_meu.zip', 'rb') as f:\n"
"...    datele = f.read()\n"
"...\n"
">>> început = 0\n"
">>> for i in range(3):                # afișează primele 3 antete\n"
"...                                   # de fișier\n"
"...    început += 14\n"
"...    câmpuri = struct.unpack('<IIIHH', datele[început:început+16])\n"
"...    crc32 \\\n"
"...    ,mărime_comprimate \\\n"
"...    ,mărime_necomprimate \\\n"
"...    ,mărime_numedefișier \\\n"
"...    ,mărime_suplimentar = câmpuri\n"
"...    început += 16\n"
"...    numedefișier = datele[început:început+mărime_numedefișier]\n"
"...    început += mărime_numedefișier\n"
"...    suplimentar = datele[început:început+mărime_suplimentar]\n"
"...    print(numedefișier \\\n"
"...          ,hex(crc32) \\\n"
"...          ,mărime_comprimate \\\n"
"...          ,mărime_necomprimate)\n"
"...    început += mărime_suplimentar \\\n"
"...             + mărime_necomprimate # trecem la antetul următor"

#: ../../tutorial/stdlib2.rst:167
msgid "Multi-threading"
msgstr "Execuții multifilare"

#: ../../tutorial/stdlib2.rst:169
msgid ""
"Threading is a technique for decoupling tasks which are not sequentially "
"dependent.  Threads can be used to improve the responsiveness of "
"applications that accept user input while other tasks run in the "
"background.  A related use case is running I/O in parallel with "
"computations in another thread."
msgstr ""
"Execuția *pe mai multe fire* (sau *multifir* ori *multifilară*; de la "
"englezescul *threading*) a unui program este o tehnică de organizare a "
"execuției acestuia prin care se decuplează *sarcinile* (sau *subunitățile*; "
"de la englezescul *task*) programului care nu depind (în mod direct) una "
"de cealaltă. *Firele de execuție* (numite și *procese de categorie "
"ușoară*) pot fi întrebuințate pentru a îmbunătăți *receptivitatea* unei "
"aplicații la acțiunile utilizatorului său în timp ce execuția sarcinilor "
"de durată se desfășoară *în fundal* (asincron). Un caz de utilizare "
"relevant este cel al *rulării* (îndeplinirii) unor sarcini I/E (mai lente, "
"de obicei) *în paralel* cu realizarea de sarcini de calcul, acestea din "
"urmă fiind efectuate în alt fir de execuție."

#: ../../tutorial/stdlib2.rst:174
msgid ""
"The following code shows how the high level :mod:`threading` module can "
"run tasks in background while the main program continues to run::"
msgstr ""
"Fragmentul de cod care urmează ne arată cum poate modulul de nivel înalt "
":mod:`threading` să execute sarcini în fundal pe când programul principal "
"rulează (în prim-plan)::"

#: ../../tutorial/stdlib2.rst:177
msgid ""
"import threading, zipfile\n"
"\n"
"class AsyncZip(threading.Thread):\n"
"    def __init__(self, infile, outfile):\n"
"        threading.Thread.__init__(self)\n"
"        self.infile = infile\n"
"        self.outfile = outfile\n"
"\n"
"    def run(self):\n"
"        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\n"
"        f.write(self.infile)\n"
"        f.close()\n"
"        print('Finished background zip of:', self.infile)\n"
"\n"
"background = AsyncZip('mydata.txt', 'myarchive.zip')\n"
"background.start()\n"
"print('The main program continues to run in foreground.')\n"
"\n"
"background.join()    # Wait for the background task to finish\n"
"print('Main program waited until background was done.')"
msgstr ""
"import threading, zipfile\n"
"\n"
"class ArhivareaZipAsincronă(threading.Thread):\n"
"    def __init__(self, fișier_de_intrare, fișier_de_ieșire):\n"
"        threading.Thread.__init__(self)\n"
"        self.fișier_de_intrare = fișier_de_intrare\n"
"        self.fișier_de_ieșire = fișier_de_ieșire\n"
"\n"
"    def run(self):    # suprascriem metoda run() a clasei Thread\n"
"        f = zipfile.ZipFile(self.fișier_de_ieșire, 'w', \\\n"
"                            zipfile.ZIP_DEFLATED)\n"
"        f.write(self.fișier_de_intrare)\n"
"        f.close()\n"
"        print('Terminat arhivarea zip, în fundal, a lui:', \\\n"
"              self.fișier_de_intrare)\n"
"\n"
"în_fundal = ArhivareaZipAsincronă('datele_mele.txt', 'arhiva_mea.zip')\n"
"în_fundal.start()\n"
"print('Programul principal rulează (în continuare) în prim-plan.')\n"
"\n"
"în_fundal.join()    # Așteptăm să se încheie sarcina de fundal\n"
"print('Programul principal a așteptat încheierea sarcinii de fundal.')"

#: ../../tutorial/stdlib2.rst:198
msgid ""
"The principal challenge of multi-threaded applications is coordinating "
"threads that share data or other resources.  To that end, the threading "
"module provides a number of synchronization primitives including locks, "
"events, condition variables, and semaphores."
msgstr ""
"Dificultatea principală a aplicațiilor *multifir* (adică, a aplicațiilor "
"cu execuție pe mai multe fire) este cea a *coordonării* acestor fire de "
"execuție vizavi de accesul la date ori la alte resurse (memorie, șamd.). "
"În acest scop, modulul *threading* ne furnizează un număr de *primitive "
"de sincronizare*, precum *blocări* (sau *zăvoare*; de la englezescul "
"*lock*), evenimente, variabile de control și semafoare."

#: ../../tutorial/stdlib2.rst:203
msgid ""
"While those tools are powerful, minor design errors can result in "
"problems that are difficult to reproduce.  So, the preferred approach to "
"task coordination is to concentrate all access to a resource in a single "
"thread and then use the :mod:`queue` module to feed that thread with "
"requests from other threads. Applications using :class:`~queue.Queue` "
"objects for inter-thread communication and coordination are easier to "
"design, more readable, and more reliable."
msgstr ""
"Chiar dacă aceste unelte sunt puternice, erorile de proiectare (fie și) "
"minore ne pot pune în fața unor complicații dificil de reprodus (în "
"mod sistematic). Din acest motiv, abordarea preferată în practică în "
"ceea ce privește coordonarea sarcinilor este să realizăm (toată) "
"accesarea resurselor într-un singur fir de execuție și să utilizăm modulul "
":mod:`queue` pentru a *hrăni* acest fir cu *cereri* din partea celorlalte "
"fire de execuție. Aplicațiile care întrebuințează obiecte "
":class:`~queue.Queue` pentru *comunicarea între fire* (sau *comunicarea "
"interprocese*) și pentru coordonarea acestora sunt (mai) ușor de proiectat, "
"(mai) stabile și au codul-sursă (mai) facil de citit."

#: ../../tutorial/stdlib2.rst:214
msgid "Logging"
msgstr "Jurnalizarea"

#: ../../tutorial/stdlib2.rst:216
msgid ""
"The :mod:`logging` module offers a full featured and flexible logging "
"system. At its simplest, log messages are sent to a file or to "
"``sys.stderr``::"
msgstr ""
"Modulul :mod:`logging` ne pune la dispoziție un sistem de jurnalizare "
"flexibil și complet accesorizat. Folosite în modul cel mai simplu cu "
"putință, mesajele de (introdus în) jurnal îi sunt transmise fie unui "
"fișier (prestabilit) fie (fluxului) ``sys.stderr``::"

#: ../../tutorial/stdlib2.rst:219
#, python-format
msgid ""
"import logging\n"
"logging.debug('Debugging information')\n"
"logging.info('Informational message')\n"
"logging.warning('Warning:config file %s not found', 'server.conf')\n"
"logging.error('Error occurred')\n"
"logging.critical('Critical error -- shutting down')"
msgstr ""
"import logging\n"
"logging.debug('Informații de depanare')\n"
"logging.info('Mesaj de informare')\n"
"logging.warning('Avertisment: fișierul de configurare %s negăsit', 'serverul.conf')\n"
"logging.error('Eroare survenită')\n"
"logging.critical('Eroare critică -- opresc sistemul')"

#: ../../tutorial/stdlib2.rst:226
msgid "This produces the following output:"
msgstr "Iată ce se va afișa:"

#: ../../tutorial/stdlib2.rst:228
msgid ""
"WARNING:root:Warning:config file server.conf not found\n"
"ERROR:root:Error occurred\n"
"CRITICAL:root:Critical error -- shutting down"
msgstr ""
"WARNING:root:Avertisment: fișierul de configurare serverul.conf negăsit\n"
"ERROR:root:Eroare survenită\n"
"CRITICAL:root:Eroare critică -- opresc sistemul"

#: ../../tutorial/stdlib2.rst:234
msgid ""
"By default, informational and debugging messages are suppressed and the "
"output is sent to standard error.  Other output options include routing "
"messages through email, datagrams, sockets, or to an HTTP Server.  New "
"filters can select different routing based on message priority: "
":const:`~logging.DEBUG`, :const:`~logging.INFO`, "
":const:`~logging.WARNING`, :const:`~logging.ERROR`, and "
":const:`~logging.CRITICAL`."
msgstr ""
"În mod prestabilit, atât mesajele informative cât și cele de depanare sunt "
"suprimate (de la jurnalizare) în timp ce ieșirea (conținutul) lor se "
"trimite către fluxul standard de eroare. Alte opțiuni de ieșire includ "
"*distribuirea* (sau *rutarea*; de la englezescul, ca jargon informatic, "
"*routing*) mesajelor prin poșta electronică, datagrame, socluri, ori către "
"un server HTTP. Filtre suplimentare permit alegerea unor distribuiri bazate "
"pe *prioritatea mesajelor*: "
":const:`~logging.DEBUG`, :const:`~logging.INFO`, "
":const:`~logging.WARNING`, :const:`~logging.ERROR`, precum și "
":const:`~logging.CRITICAL`."

#: ../../tutorial/stdlib2.rst:241
msgid ""
"The logging system can be configured directly from Python or can be "
"loaded from a user editable configuration file for customized logging "
"without altering the application."
msgstr ""
"Sistemul de jurnalizare se poate configura atât direct din Python cât și "
"indirect, prin încărcarea setărilor dintr-un fișier de configurare care "
"poate fi editat de către utilizator, permițându-se astfel jurnalizări "
"personalizate a căror introducere să nu necesite modificarea codului-"
"sursă de bază al aplicației."

#: ../../tutorial/stdlib2.rst:249
msgid "Weak References"
msgstr "Referințe slabe"

#: ../../tutorial/stdlib2.rst:251
msgid ""
"Python does automatic memory management (reference counting for most "
"objects and :term:`garbage collection` to eliminate cycles).  The memory "
"is freed shortly after the last reference to it has been eliminated."
msgstr ""
"Python-ul își administrează memoria în mod automat (realizând atât "
"*contorizarea referințelor* pentru majoritatea obiectelor cât și "
":term:`garbage collection` pentru eliminarea *circularităților*). "
"Orice zonă de memorie (rezervată) va fi eliberată la puțin timp după ce a "
"fost eliminată (și) ultima referință la ea."

#: ../../tutorial/stdlib2.rst:255
msgid ""
"This approach works fine for most applications but occasionally there is "
"a need to track objects only as long as they are being used by something "
"else. Unfortunately, just tracking them creates a reference that makes "
"them permanent. The :mod:`weakref` module provides tools for tracking "
"objects without creating a reference.  When the object is no longer "
"needed, it is automatically removed from a weakref table and a callback "
"is triggered for weakref objects.  Typical applications include caching "
"objects that are expensive to create::"
msgstr ""
"O atare abordare funcționează mulțumitor pentru cele mai multe dintre "
"aplicații, însă câteodată este nevoie ca urmărirea anumitor obiecte să "
"fie realizată doar atâta vreme cât ceva anume (din sistem) le "
"întrebuințează. Din păcate, simpla urmărire a unui obiect creează o "
"referință la acesta, care referință îl va face permanent (nemuritor). "
"Modulul :mod:`weakref` conține unelte pentru urmărirea unor obiecte fără "
"să se creeze nicio referință la ele. Atunci când un obiect anume nu mai "
"este folosit, el va fi eliminat automat dintr-o tabelă de *referințe slabe* "
"(de la englezescul, ca jargon informatic, *weakref*) și o *rutină de "
"răspuns* (sau un *apel de răspuns*; de la englezescul, ca jargon "
"informatic, *callback*) va fi declanșată pentru respectivul obiect "
"*weakref*. Întrebuințările tipice ale referințelor slabe includ *memorarea "
"locală rapidă* (de la englezescul, ca jargon informatic, *caching*) a "
"obiectelor care sunt costisitor de creat::"

#: ../../tutorial/stdlib2.rst:263
msgid ""
">>> import weakref, gc\n"
">>> class A:\n"
"...     def __init__(self, value):\n"
"...         self.value = value\n"
"...     def __repr__(self):\n"
"...         return str(self.value)\n"
"...\n"
">>> a = A(10)                   # create a reference\n"
">>> d = weakref.WeakValueDictionary()\n"
">>> d['primary'] = a            # does not create a reference\n"
">>> d['primary']                # fetch the object if it is still alive\n"
"10\n"
">>> del a                       # remove the one reference\n"
">>> gc.collect()                # run garbage collection right away\n"
"0\n"
">>> d['primary']                # entry was automatically removed\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    d['primary']                # entry was automatically removed\n"
"  File \"C:/python313/lib/weakref.py\", line 46, in __getitem__\n"
"    o = self.data[key]()\n"
"KeyError: 'primary'"
msgstr ""
">>> import weakref, gc\n"
">>> class A:\n"
"...     def __init__(self, valoarea):\n"
"...         self.valoarea = valoarea\n"
"...     def __repr__(self):\n"
"...         return str(self.valoarea)\n"
"...\n"
">>> a = A(10)                            # creăm o referință (x)\n"
">>> dicționarul = weakref.WeakValueDictionary()\n"
">>> dicționarul['referință primară'] = a # nu creează nicio referință\n"
">>> dicționarul['referință primară']     # găsește-l, dacă e în viață\n"
"10\n"
">>> del a                                # elimină referința (x)\n"
">>> gc.collect()                         # colectează gunoiul (chiar acum)\n"
"0\n"
">>> dicționarul['referință primară']     # eliminat automat din tabelă\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    dicționarul['referință primară']     # eliminat automat din tabelă\n"
"  File \"C:/python313/lib/weakref.py\", line 46, in __getitem__\n"
"    o = self.data[key]()\n"
"KeyError: 'referință primară'"

#: ../../tutorial/stdlib2.rst:290
msgid "Tools for Working with Lists"
msgstr "Unelte pentru lucrul cu liste"

#: ../../tutorial/stdlib2.rst:292
msgid ""
"Many data structure needs can be met with the built-in list type. "
"However, sometimes there is a need for alternative implementations with "
"different performance trade-offs."
msgstr ""
"Multe din cerințele unor structuri (abstracte) de date pot fi deservite "
"de tipul predefinit (de date) *listă*. Cu toate acestea, în anumite "
"situații este nevoie de implementări alternative ale unei structuri de "
"date, punându-se în balanță, la alegerea lor, *performanțe* specifice."

#: ../../tutorial/stdlib2.rst:296
msgid ""
"The :mod:`array` module provides an :class:`~array.array` object that is "
"like a list that stores only homogeneous data and stores it more "
"compactly.  The following example shows an array of numbers stored as two"
" byte unsigned binary numbers (typecode ``\"H\"``) rather than the usual "
"16 bytes per entry for regular lists of Python int objects::"
msgstr ""
"Modulul :mod:`array` dispune de obiectul :class:`~array.array` (adică, "
"tipul *tablou*, *vector* ori *matrice*) care îi seamănă listei, doar că nu "
"poate stoca decât date de același tip (omogene) iar stocarea propriu-zisă "
"se face (mai) compact. Exemplul de mai jos prezintă un tablou de numere "
"întregi stocate sub formă de numere binare fără semn (lungi) de câte doi "
"octeți (și având *codul de tip* ``\"H\"``), aceasta spre deosebire de "
"cazul listelor Python uzuale formate din obiecte *int*, în care fiecare "
"item este stocat pe câte 16 octeți::"

#: ../../tutorial/stdlib2.rst:302
msgid ""
">>> from array import array\n"
">>> a = array('H', [4000, 10, 700, 22222])\n"
">>> sum(a)\n"
"26932\n"
">>> a[1:3]\n"
"array('H', [10, 700])"
msgstr ""
">>> from array import array\n"
">>> tablou = array('H', [4000, 10, 700, 22222])\n"
">>> sum(tablou)\n"
"26932\n"
">>> tablou[1:3]\n"
"array('H', [10, 700])"

#: ../../tutorial/stdlib2.rst:309
msgid ""
"The :mod:`collections` module provides a :class:`~collections.deque` "
"object that is like a list with faster appends and pops from the left "
"side but slower lookups in the middle. These objects are well suited for "
"implementing queues and breadth first tree searches::"
msgstr ""
"Modulul :mod:`collections` ne furnizează obiectul "
":class:`~collections.deque` (adică, tipul *deque* ori *coadă cu două "
"capete*) care îi seamănă listei, doar că acceptă (de la englezescul "
"*append*) și elimină (de la englezescul *pop*) itemi la și de la "
"capete mai repede decât o poate face o listă, respectiv caută itemi (de la "
"englezescul *lookup*) mai încet decât poate o listă atunci când itemii "
"respectivi se găsesc în interiorul (mijlocul) său. Instanțele acestui tip "
"sunt cum nu se poate mai potrivite pentru implementarea de *cozi* (FIFO, "
"LIFO), respectiv de *căutări în lățime* (a unor itemi) în diverși *arbori* "
"de date::"

#: ../../tutorial/stdlib2.rst:314
msgid ""
">>> from collections import deque\n"
">>> d = deque([\"task1\", \"task2\", \"task3\"])\n"
">>> d.append(\"task4\")\n"
">>> print(\"Handling\", d.popleft())\n"
"Handling task1"
msgstr ""
">>> from collections import deque\n"
">>> coada_cu_două_capete = deque([\"sarcina1\", \"sarcina2\", \\\n"
"...                               \"sarcina3\"])\n"
">>> coada_cu_două_capete.append(\"sarcina4\")\n"
">>> print(\"Mă ocup de \", coada_cu_două_capete.popleft())\n"
"Mă ocup de sarcina1"

#: ../../tutorial/stdlib2.rst:322
msgid ""
"unsearched = deque([starting_node])\n"
"def breadth_first_search(unsearched):\n"
"    node = unsearched.popleft()\n"
"    for m in gen_moves(node):\n"
"        if is_goal(m):\n"
"            return m\n"
"        unsearched.append(m)"
msgstr ""
"unde_caut = deque([nodul_de_început])\n"
"def căutare_în_lățime(unde_caut):     # căutare breadth-first\n"
"    nodul = unde_caut.popleft()\n"
"    for c in ce_mi_am_propus(nodul):\n"
"        if este_țelul_meu(c):\n"
"            return c\n"
"        unde_caut.append(c)"

#: ../../tutorial/stdlib2.rst:330
msgid ""
"In addition to alternative list implementations, the library also offers "
"other tools such as the :mod:`bisect` module with functions for "
"manipulating sorted lists::"
msgstr ""
"În plus față de implementările alternative ale *listei*, biblioteca ne pune "
"la dispoziție și altfel de unelte, precum cele din modulul :mod:`bisect` "
"care conține funcții pentru manipularea listelor (deja) *sortate*::"

#: ../../tutorial/stdlib2.rst:334
msgid ""
">>> import bisect\n"
">>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]"
"\n"
">>> bisect.insort(scores, (300, 'ruby'))\n"
">>> scores\n"
"[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, "
"'python')]"
msgstr ""
">>> import bisect\n"
">>> scoruri = [(100, 'Perl'), (200, 'Tcl'), (400, 'Lua'), (500, 'Python')]"
"\n"
">>> bisect.insort(scoruri, (300, 'Ruby'))\n"
">>> scoruri\n"
"[(100, 'Perl'), (200, 'Tcl'), (300, 'Ruby'), (400, 'Lua'), (500, "
"'Python')]"

#: ../../tutorial/stdlib2.rst:340
msgid ""
"The :mod:`heapq` module provides functions for implementing heaps based "
"on regular lists.  The lowest valued entry is always kept at position "
"zero.  This is useful for applications which repeatedly access the "
"smallest element but do not want to run a full list sort::"
msgstr ""
"Modulul :mod:`heapq` deține funcții pentru implementarea structurilor "
"arborescente *heap* (adică, generic, *grămadă*; se utilizează de multe "
"ori, în mod superficial, și expresia *coadă cu priorități*) folosind "
"*lista* obișnuită. Itemul cu *cea mai mică valoare* este păstrat "
"întotdeauna în poziția *zero*. Această caracteristică a structurilor *heap* "
"le face să fie de folos pentru aplicațiile în care accesăm în mod frecvent "
"elementul cu cea mai mică valoare (dintr-o listă de valori) dar nu dorim "
"să realizăm o sortare completă a listei::"

#: ../../tutorial/stdlib2.rst:345
msgid ""
">>> from heapq import heapify, heappop, heappush\n"
">>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n"
">>> heapify(data)                      # rearrange the list into heap "
"order\n"
">>> heappush(data, -5)                 # add a new entry\n"
">>> [heappop(data) for i in range(3)]  # fetch the three smallest entries"
"\n"
"[-5, 0, 1]"
msgstr ""
">>> from heapq import heapify, heappop, heappush\n"
">>> datele = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n"
">>> # reorganizăm lista pentru a avea o ordonare de heap:\n"
">>> heapify(datele)\n"
">>> heappush(datele, -5)               # introducem un item\n"
">>> # extragem cele mai mici trei valori:\n"
">>> [heappop(datele) for i in range(3)]\n"
"[-5, 0, 1]"

#: ../../tutorial/stdlib2.rst:356
msgid "Decimal Floating-Point Arithmetic"
msgstr "Aritmetică în virgulă mobilă pentru numere zecimale"

#: ../../tutorial/stdlib2.rst:358
msgid ""
"The :mod:`decimal` module offers a :class:`~decimal.Decimal` datatype for"
" decimal floating-point arithmetic.  Compared to the built-in "
":class:`float` implementation of binary floating point, the class is "
"especially helpful for"
msgstr ""
"Modulul :mod:`decimal` ne oferă tipul de date :class:`~decimal.Decimal`, "
"dedicat aritmeticii zecimale în virgulă mobilă. Prin comparație cu "
"implementarea predefinită :class:`float` a numerelor binare în virgulă "
"mobilă, clasa de față este realmente utilă pentru"

#: ../../tutorial/stdlib2.rst:362
msgid ""
"financial applications and other uses which require exact decimal "
"representation,"
msgstr ""
"aplicațiile financiare ori alte aplicații în care se cer *reprezentări "
"exacte* în baza zece ale datelor numerice,"

#: ../../tutorial/stdlib2.rst:364
msgid "control over precision,"
msgstr "situațiile în care *controlul* (numerelor) este mai important "
"decât *precizia* (cifrelor din dreapta virgulei),"

#: ../../tutorial/stdlib2.rst:365
msgid "control over rounding to meet legal or regulatory requirements,"
msgstr ""
"cazurile când *rotunjirea* valorilor numerice trebuie să țină seama de "
"cerințe legale sau de alte reglementări specifice,"

#: ../../tutorial/stdlib2.rst:366
msgid "tracking of significant decimal places, or"
msgstr ""
"monitorizea cifrelor zecimale *semnificative* din dreapta punctului "
"(virgulei), respectiv pentru"

#: ../../tutorial/stdlib2.rst:367
msgid ""
"applications where the user expects the results to match calculations "
"done by hand."
msgstr ""
"aplicațiile la care utilizatorul se așteaptă ca rezultatele diverselor "
"operații să se potrivească cu cele obținute chiar de el în urma calculelor "
"*făcute cu creionul pe hârtie*."

#: ../../tutorial/stdlib2.rst:370
msgid ""
"For example, calculating a 5% tax on a 70 cent phone charge gives "
"different results in decimal floating point and binary floating point. "
"The difference becomes significant if the results are rounded to the "
"nearest cent::"
msgstr ""
"Cu titlu de exemplu, calculul unei taxe de 5% la valoarea de 70 de cenți a "
"unei facturi de convorbiri telefonice produce un rezultat diferit, atunci "
"când este efectuat în virgulă mobilă *binară*, de rezultatul obținut în "
"virgulă mobilă *zecimală*. Iar diferența nu mai poate fi trecută cu vederea "
"dacă rotunjim rezultatele până la obținerea *celui mai apropiat* cent::"

#: ../../tutorial/stdlib2.rst:374
msgid ""
">>> from decimal import *\n"
">>> round(Decimal('0.70') * Decimal('1.05'), 2)\n"
"Decimal('0.74')\n"
">>> round(.70 * 1.05, 2)\n"
"0.73"
msgstr ""
">>> from decimal import *\n"
">>> round(Decimal('0.70') * Decimal('1.05'), 2)\n"
"Decimal('0.74')\n"
">>> round(.70 * 1.05, 2)\n"
"0.73"

#: ../../tutorial/stdlib2.rst:380
msgid ""
"The :class:`~decimal.Decimal` result keeps a trailing zero, automatically"
" inferring four place significance from multiplicands with two place "
"significance.  Decimal reproduces mathematics as done by hand and avoids "
"issues that can arise when binary floating point cannot exactly represent"
" decimal quantities."
msgstr ""
"Rezultatul :class:`~decimal.Decimal` păstrează zerouri pe post de sufix, "
"presupunând în mod automat că, în urma multiplicării unor operanzi cu câte "
"două cifre semnificative la dreapta punctului, el va avea patru cifre "
"semnificative după punct. Clasa *Decimal* reproduce matematica făcută cu "
"creionul pe hârtie și evită, astfel, complicații care pot surveni atunci "
"când anumite cantități zecimale nu sunt reprezentabile exact cu valori "
"binare în virgulă mobilă."

#: ../../tutorial/stdlib2.rst:386
msgid ""
"Exact representation enables the :class:`~decimal.Decimal` class to "
"perform modulo calculations and equality tests that are unsuitable for "
"binary floating point::"
msgstr ""
"Întrebuințarea de reprezentări exacte îi permite clasei "
":class:`~decimal.Decimal` să realizeze atât împărțiri cu rest (calcule "
"cu operatorul *modulo*) cât și testări de egalități care nu sunt "
"realizabile cu numere binare în virgulă mobilă::"

#: ../../tutorial/stdlib2.rst:390
msgid ""
">>> Decimal('1.00') % Decimal('.10')\n"
"Decimal('0.00')\n"
">>> 1.00 % 0.10\n"
"0.09999999999999995\n"
"\n"
">>> sum([Decimal('0.1')]*10) == Decimal('1.0')\n"
"True\n"
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False"
msgstr ""
">>> Decimal('1.00') % Decimal('.10')\n"
"Decimal('0.00')\n"
">>> 1.00 % 0.10\n"
"0.09999999999999995\n"
"\n"
">>> sum([Decimal('0.1')]*10) == Decimal('1.0')\n"
"True\n"
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False"

#: ../../tutorial/stdlib2.rst:400
msgid ""
"The :mod:`decimal` module provides arithmetic with as much precision as "
"needed::"
msgstr ""
"În modulul :mod:`decimal`, aritmetica poate fi efectuată cu *precizia* "
"stabilită de către utilizator::"

#: ../../tutorial/stdlib2.rst:402
msgid ""
">>> getcontext().prec = 36\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857')"
msgstr ""
">>> getcontext().prec = 36\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857')"


