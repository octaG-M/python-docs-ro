# TURUL PE SCURT AL BIBLIOTECII STANDARD.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Octavian Mustafa <octawian@yahoo.com>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-17 17:56+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ro\n"
"Language-Team: ro <octawian@yahoo.com>\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : (n==0 || (n%100 > 0 && n%100"
" < 20)) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorial/stdlib.rst:5
msgid "Brief Tour of the Standard Library"
msgstr "Turul pe scurt al bibliotecii standard"

#: ../../tutorial/stdlib.rst:11
msgid "Operating System Interface"
msgstr "Interfața cu sistemul de operare"

#: ../../tutorial/stdlib.rst:13
msgid ""
"The :mod:`os` module provides dozens of functions for interacting with "
"the operating system::"
msgstr ""
"Modulul :mod:`os` ne furnizează o cantitate consistentă de funcții pentru "
"interacțiunea cu sistemul de operare::"

#: ../../tutorial/stdlib.rst:16
msgid ""
">>> import os\n"
">>> os.getcwd()      # Return the current working directory\n"
"'C:\\\\Python313'\n"
">>> os.chdir('/server/accesslogs')   # Change current working directory\n"
">>> os.system('mkdir today')   # Run the command mkdir in the system "
"shell\n"
"0"
msgstr ""
">>> import os\n"
">>> # Returnează directorul curent (în care ne găsim chiar acum):\n"
">>> os.getcwd()\n"                           
"'C:\\\\Python313'\n"
">>> # Schimbăm directorul curent:\n"
">>> os.chdir('/serverul/jurnalul_accesărilor')\n"
">>> # Rulăm comanda mkdir în interpretorul de comenzi (shell)\n"
">>> # al sistemului:\n"
">>> os.system('mkdir lucru_astăzi')\n"
"0"

#: ../../tutorial/stdlib.rst:23
msgid ""
"Be sure to use the ``import os`` style instead of ``from os import *``.  "
"This will keep :func:`os.open` from shadowing the built-in :func:`open` "
"function which operates much differently."
msgstr ""
"Aveți grijă să realizați importul în *stilul* dat de ``import os`` și nu "
"scriind ``from os import *``. Astfel, veți evita ca apelarea funcției "
":func:`os.open` să se producă în locul celei a funcției predefinite "
":func:`open`, aceasta din urmă funcționând complet diferit."

#: ../../tutorial/stdlib.rst:29
msgid ""
"The built-in :func:`dir` and :func:`help` functions are useful as "
"interactive aids for working with large modules like :mod:`os`::"
msgstr ""
"Funcțiile predefinite :func:`dir` și :func:`help` ne vor fi utile ca "
"ajutoare *interactive* atunci când lucrăm cu module masive, precum "
":mod:`os`::"

#: ../../tutorial/stdlib.rst:32
msgid ""
">>> import os\n"
">>> dir(os)\n"
"<returns a list of all module functions>\n"
">>> help(os)\n"
"<returns an extensive manual page created from the module's docstrings>"
msgstr ""
">>> import os\n"
">>> dir(os)\n"
"<returnează o listă cu toate funcțiile din modul>\n"
">>> help(os)\n"
"<returnează o pagină extensivă de manual, bazată pe docstring-ul modulului>"

#: ../../tutorial/stdlib.rst:38
msgid ""
"For daily file and directory management tasks, the :mod:`shutil` module "
"provides a higher level interface that is easier to use::"
msgstr ""
"Pentru sarcinile administrative zilnice privind fișierele și directoarele, "
"modulul :mod:`shutil` ne pune la dispoziție o interfață de nivel înalt care "
"este (mai) ușor de întrebuințat::"

#: ../../tutorial/stdlib.rst:41
msgid ""
">>> import shutil\n"
">>> shutil.copyfile('data.db', 'archive.db')\n"
"'archive.db'\n"
">>> shutil.move('/build/executables', 'installdir')\n"
"'installdir'"
msgstr ""
">>> import shutil\n"
">>> shutil.copyfile('datele.db', 'arhiva.db')\n"
"'arhiva.db'\n"
">>> shutil.move('/build/executabilele', 'directorul_instalării')\n"
"'directorul_instalării'"

#: ../../tutorial/stdlib.rst:51
msgid "File Wildcards"
msgstr "Caractere de înlocuire pentru fișiere"

#: ../../tutorial/stdlib.rst:53
msgid ""
"The :mod:`glob` module provides a function for making file lists from "
"directory wildcard searches::"
msgstr ""
"Modulul :mod:`glob` dispune de o funcție care realizează liste de fișiere "
"bazate pe căutări cu *caractere de înlocuire* (sau *meta-caractere*; de la "
"englezescul *wildcard*) în directorul curent (și nu numai)::"

#: ../../tutorial/stdlib.rst:56
msgid ""
">>> import glob\n"
">>> glob.glob('*.py')\n"
"['primes.py', 'random.py', 'quote.py']"
msgstr ""
">>> import glob\n"
">>> glob.glob('*.py')\n"
"['numere_prime.py', 'numere_aleatoare.py', 'cote.py']"

#: ../../tutorial/stdlib.rst:64
msgid "Command Line Arguments"
msgstr "Argumente în linia de comandă"

#: ../../tutorial/stdlib.rst:66
msgid ""
"Common utility scripts often need to process command line arguments. "
"These arguments are stored in the :mod:`sys` module's *argv* attribute as"
" a list.  For instance, let's take the following :file:`demo.py` file::"
msgstr ""
"Scripturile utilitare pe care le întrebuințăm în mod obișnuit necesită "
"adesea procesarea argumentelor primite în linia de comandă. Aceste "
"argumente sunt stocate, sub formă de listă, în atributul *argv* al "
"modulului :mod:`sys`. De exemplu, să presupunem că avem un fișier "
":file:`demonstrativ.py`, cu următorul conținut::"

#: ../../tutorial/stdlib.rst:70
msgid ""
"# File demo.py\n"
"import sys\n"
"print(sys.argv)"
msgstr ""
"# Fișierul demonstrativ.py\n"
"import sys\n"
"print(sys.argv)"

#: ../../tutorial/stdlib.rst:74
msgid ""
"Here is the output from running ``python demo.py one two three`` at the "
"command line::"
msgstr ""
"Iată ce se va obține în urma execuției comenzii "
"``python demonstrativ.py unu doi trei`` în linie de comandă::"

#: ../../tutorial/stdlib.rst:77
msgid "['demo.py', 'one', 'two', 'three']"
msgstr "['demonstrativ.py', 'unu', 'doi', 'trei']"

#: ../../tutorial/stdlib.rst:79
msgid ""
"The :mod:`argparse` module provides a more sophisticated mechanism to "
"process command line arguments.  The following script extracts one or "
"more filenames and an optional number of lines to be displayed::"
msgstr ""
"Modulul :mod:`argparse` ne oferă un mecanism (mai) sofisticat pentru "
"manipularea argumentelor primite în linia de comandă. Scriptul de mai jos "
"extrage (din șirul de caractere al liniei de comandă) unul sau mai multe "
"nume de fișiere, respectiv numărul opțional de rânduri ce urmează a fi "
"afișate din fiecare din fișierele cu numele extrase::"

#: ../../tutorial/stdlib.rst:83
msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(\n"
"    prog='top',\n"
"    description='Show top lines from each file')\n"
"parser.add_argument('filenames', nargs='+')\n"
"parser.add_argument('-l', '--lines', type=int, default=10)\n"
"args = parser.parse_args()\n"
"print(args)"
msgstr ""
"# Conținutul scriptului capturi_de_la_început.py\n"
"import argparse\n"
"\n"
"parserul = argparse.ArgumentParser(\n"
"    prog='capturi_de_la_început',\n"
"    description='Afișează primele rânduri din fiecare fișier')\n"
"parserul.add_argument('nume_de_fișiere', nargs='+')\n"
"parserul.add_argument('-l', '--rânduri', type=int, default=10)\n"
"argumentele = parserul.parse_args()\n"
"print(argumentele)"

#: ../../tutorial/stdlib.rst:93
msgid ""
"When run at the command line with ``python top.py --lines=5 alpha.txt "
"beta.txt``, the script sets ``args.lines`` to ``5`` and "
"``args.filenames`` to ``['alpha.txt', 'beta.txt']``."
msgstr ""
"Atunci când rulăm în linie de comandă "
"``python capturi_de_la_început.py --rânduri=5 alfa.txt beta.txt``, scriptul "
"îi va atribui lui ``argumentele.rânduri`` valoarea ``5`` iar lui "
"``argumentele.nume_de_fișiere`` valoarea ``['alfa.txt', 'beta.txt']``."

#: ../../tutorial/stdlib.rst:101
msgid "Error Output Redirection and Program Termination"
msgstr "Redirecționarea ieșirii erorilor și încheierea programelor"

#: ../../tutorial/stdlib.rst:103
msgid ""
"The :mod:`sys` module also has attributes for *stdin*, *stdout*, and "
"*stderr*. The latter is useful for emitting warnings and error messages "
"to make them visible even when *stdout* has been redirected::"
msgstr ""
"Modulul :mod:`sys` deține atribute și pentru *stdin*, *stdout*, respectiv "
"pentru *stderr*. Acesta din urmă este de folos la emiterea avertismentelor "
"și a mesajelor de eroare, chiar și atunci când (fluxul) *stdout* a fost "
"redirecționat::"

#: ../../tutorial/stdlib.rst:107
msgid ""
">>> sys.stderr.write('Warning, log file not found starting a new one\\n')"
"\n"
"Warning, log file not found starting a new one"
msgstr ""
">>> sys.stderr.write('Atenție, nu găsesc jurnalul, încep unul nou\\n')"
"\n"
"Atenție, nu găsesc jurnalul, încep unul nou"

#: ../../tutorial/stdlib.rst:110
msgid "The most direct way to terminate a script is to use ``sys.exit()``."
msgstr ""
"Modul (cel mai) direct de a *încheia* (de la englezescul *terminate*) "
"execuția unui script este să utilizăm ``sys.exit()``."

#: ../../tutorial/stdlib.rst:116
msgid "String Pattern Matching"
msgstr "Identificarea după tipare a șirurilor de caractere"

#: ../../tutorial/stdlib.rst:118
msgid ""
"The :mod:`re` module provides regular expression tools for advanced "
"string processing. For complex matching and manipulation, regular "
"expressions offer succinct, optimized solutions::"
msgstr ""
"Modulul :mod:`re` ne pune la dispoziție unelte care utilizează *expresii "
"regulate* pentru procesări complexe ale șirurilor de caractere. Atunci "
"când suntem interesați de identificări (de la englezescul *matching*) și "
"manipulări sofisticate, expresiile regulate ne vin în ajutor cu soluții "
"succinte, optimizate::"

#: ../../tutorial/stdlib.rst:122
msgid ""
">>> import re\n"
">>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n"
"['foot', 'fell', 'fastest']\n"
">>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n"
"'cat in the hat'"
msgstr ""
">>> import re\n"
">>> re.findall(r'\\bm[a-zăâ]*', 'cine, maică, mâna ori mâncarea pică la măcel')\n"
"['maică', 'mâna', 'mâncarea', 'măcel']\n"
">>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'hap pe pe halat')\n"
"'hap pe halat'"

#: ../../tutorial/stdlib.rst:128
msgid ""
"When only simple capabilities are needed, string methods are preferred "
"because they are easier to read and debug::"
msgstr ""
"Atunci când avem sarcini de identificare simple, metodele tipului *șir de "
"caractere* sunt de preferat, dat fiind că ele pot fi citite (în codul "
"Python aferent) și depanate mai ușor::"

#: ../../tutorial/stdlib.rst:131
msgid ""
">>> 'tea for too'.replace('too', 'two')\n"
"'tea for two'"
msgstr ""
">>> 'ceai pentru Mircea'.replace('Mircea', 'Cici')\n"
"'ceai pentru Cici'"

#: ../../tutorial/stdlib.rst:138
msgid "Mathematics"
msgstr "Matematică"

#: ../../tutorial/stdlib.rst:140
msgid ""
"The :mod:`math` module gives access to the underlying C library functions"
" for floating-point math::"
msgstr ""
"Modulul :mod:`math` ne facilitează accesul la funcțiile corespondente ale "
"bibliotecii C dedicate calculului (matematicii) în virgulă mobilă::"

#: ../../tutorial/stdlib.rst:143
msgid ""
">>> import math\n"
">>> math.cos(math.pi / 4)\n"
"0.70710678118654757\n"
">>> math.log(1024, 2)\n"
"10.0"
msgstr ""
">>> import math\n"
">>> math.cos(math.pi / 4)\n"
"0.70710678118654757\n"
">>> math.log(1024, 2)\n"
"10.0"

#: ../../tutorial/stdlib.rst:149
msgid "The :mod:`random` module provides tools for making random selections::"
msgstr ""
"Modulul :mod:`random` ne furnizează unelte pentru realizarea de "
"eșantioane aleatoare::"

#: ../../tutorial/stdlib.rst:151
msgid ""
">>> import random\n"
">>> random.choice(['apple', 'pear', 'banana'])\n"
"'apple'\n"
">>> random.sample(range(100), 10)   # sampling without replacement\n"
"[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n"
">>> random.random()    # random float from the interval [0.0, 1.0)\n"
"0.17970987693706186\n"
">>> random.randrange(6)    # random integer chosen from range(6)\n"
"4"
msgstr ""
">>> import random\n"
">>> random.choice(['măr', 'pară', 'banană'])\n"
"'măr'\n"
">>> random.sample(range(100), 10)   # eșantionare fără înlocuire\n"
"[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n"
">>> random.random()    # float aleator din intervalul [0.0, 1.0)\n"
"0.17970987693706186\n"
">>> random.randrange(6)    # întreg aleator ales din range(6)\n"
"4"

#: ../../tutorial/stdlib.rst:161
msgid ""
"The :mod:`statistics` module calculates basic statistical properties (the"
" mean, median, variance, etc.) of numeric data::"
msgstr ""
"Modulul :mod:`statistics` calculează proprietăți statistice de bază (media, "
"mediana, varianța șamd.) pentru datele numerice::"

#: ../../tutorial/stdlib.rst:164
msgid ""
">>> import statistics\n"
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> statistics.mean(data)\n"
"1.6071428571428572\n"
">>> statistics.median(data)\n"
"1.25\n"
">>> statistics.variance(data)\n"
"1.3720238095238095"
msgstr ""
">>> import statistics\n"
">>> datele = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> statistics.mean(datele)\n"
"1.6071428571428572\n"
">>> statistics.median(datele)\n"
"1.25\n"
">>> statistics.variance(datele)\n"
"1.3720238095238095"

#: ../../tutorial/stdlib.rst:173
msgid ""
"The SciPy project <https://scipy.org> has many other modules for "
"numerical computations."
msgstr ""
"Proiectul SciPy <https://scipy.org> deține multe alte module dedicate "
"calculului numeric."

#: ../../tutorial/stdlib.rst:179
msgid "Internet Access"
msgstr "Accesul la Internet"

#: ../../tutorial/stdlib.rst:181
msgid ""
"There are a number of modules for accessing the internet and processing "
"internet protocols. Two of the simplest are :mod:`urllib.request` for "
"retrieving data from URLs and :mod:`smtplib` for sending mail::"
msgstr ""
"Un număr de module sunt dedicate accesării Internetului și procesării "
"protocoalelor acestuia. Două din cele mai simplu de folosit module sunt "
":mod:`urllib.request`, dedicat extragerii datelor din URL-uri, și "
":mod:`smtplib`, folosit la trimiterea de scrisori electronice. (Scrisoarea "
"din exemplu conține versul shakespearian *Beware the Ides of March*. "
"Ca traducere a sa am folosit versiunea dată de `Barbu Lăzureanu "
"<https://www.editura.mttlc.ro/carti/W.%20Shakespeare."
"%20J.%20Caesar.%20B.%20Lazureanu%201892.%20CLP.pdf>`_)::"

#: ../../tutorial/stdlib.rst:185
msgid ""
">>> from urllib.request import urlopen\n"
">>> with urlopen('http://worldtimeapi.org/api/timezone/etc/UTC.txt') as "
"response:\n"
"...     for line in response:\n"
"...         line = line.decode()             # Convert bytes to a str\n"
"...         if line.startswith('datetime'):\n"
"...             print(line.rstrip())         # Remove trailing newline\n"
"...\n"
"datetime: 2022-01-01T01:36:47.689215+00:00\n"
"\n"
">>> import smtplib\n"
">>> server = smtplib.SMTP('localhost')\n"
">>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n"
"... \"\"\"To: jcaesar@example.org\n"
"... From: soothsayer@example.org\n"
"...\n"
"... Beware the Ides of March.\n"
"... \"\"\")\n"
">>> server.quit()"
msgstr ""
">>> from urllib.request import urlopen\n"
">>> with urlopen(\n"
"...     'http://worldtimeapi.org/api/timezone/Europe/Bucharest.txt') as "
"răspunsul:\n"
"...     for rândul in răspunsul:\n"
"...         # Convertește octeți în șir de caractere:\n"
"...         rândul = rândul.decode()\n"
"...         if rândul.startswith('datetime'):\n"
"...             # Elimină rândul gol de la final:\n"
"...             print(rândul.rstrip())\n"
"...\n"
"datetime: 2022-01-01T01:36:47.689215+00:00\n"
"\n"
">>> import smtplib\n"
">>> serverul_de_poștă = smtplib.SMTP('localhost')\n"
">>> serverul_de_poștă.sendmail('profetul@de_exemplu.org',\n"
"...                            'iuliu_cezar@de_exemplu.org',\n"
"... \"\"\"To: iuliu_cezar@de_exemplu.org\n"
"... From: profetul@de_exemplu.org\n"
"...\n"
"... Bagă de seamă sunt Idele lui Martie!\n"
"... \"\"\")\n"
">>> serverul_de_poștă.quit()"

#: ../../tutorial/stdlib.rst:204
msgid "(Note that the second example needs a mailserver running on localhost.)"
msgstr ""
"(Atenție, la cel de-al doilea exemplu veți avea nevoie de un server de "
"poștă electronică instalat pe *localhost*.)"

#: ../../tutorial/stdlib.rst:210
msgid "Dates and Times"
msgstr "Date calendaristice și momente de timp"

#: ../../tutorial/stdlib.rst:212
msgid ""
"The :mod:`datetime` module supplies classes for manipulating dates and "
"times in both simple and complex ways. While date and time arithmetic is "
"supported, the focus of the implementation is on efficient member "
"extraction for output formatting and manipulation.  The module also "
"supports objects that are timezone aware. ::"
msgstr ""
"Modulul :mod:`datetime` ne furnizează clase pentru manevrarea datelor "
"calendaristice și a momentelor de timp atât în moduri simple cât și în "
"feluri sofisticate. Deși calculul aritmetic cu date calendaristice și "
"momente de timp este suportat, implementarea se concentrează pe extracția "
"eficientă a componentelor (datelor temporale) în scopuri de formatare și de "
"manipulare a afișărilor. Modulul suportă inclusiv obiecte care înțeleg "
"`fusurile orare <https://ro.wikipedia.org/wiki/Fus_orar>`_ (de la "
"englezescul, ca jargon informatic, *timezone*). ::"

#: ../../tutorial/stdlib.rst:218
#, python-format
msgid ""
">>> # dates are easily constructed and formatted\n"
">>> from datetime import date\n"
">>> now = date.today()\n"
">>> now\n"
"datetime.date(2003, 12, 2)\n"
">>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n"
"'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n"
"\n"
">>> # dates support calendar arithmetic\n"
">>> birthday = date(1964, 7, 31)\n"
">>> age = now - birthday\n"
">>> age.days\n"
"14368"
msgstr ""
">>> # datele calendaristice se construiesc și se formatează ușor\n"
">>> from datetime import date\n"
">>> acum = date.today()\n"
">>> acum\n"
"datetime.date(2025, 7, 25)\n"
">>> # evităm impunerea unor \"locale\" în Windows:\n"
">>> acum.strftime(\"%d-%m-%y. %d %b %Y pică %A în ziua %d a lui %B.\")\n"
"'25-07-25. 25 Jul 2025 pică Friday în ziua 25 a lui July.'\n"
"\n"
">>> # datele calendaristice suportă aritmetica de calendar\n"
">>> ziua_de_naștere = date(1964, 7, 31)\n"
">>> vârsta = acum - ziua_de_naștere\n"
">>> vârsta.days\n"
"22274"

#: ../../tutorial/stdlib.rst:236
msgid "Data Compression"
msgstr "Compresia datelor"

#: ../../tutorial/stdlib.rst:238
msgid ""
"Common data archiving and compression formats are directly supported by "
"modules including: :mod:`zlib`, :mod:`gzip`, :mod:`bz2`, :mod:`lzma`, "
":mod:`zipfile` and :mod:`tarfile`. ::"
msgstr ""
"Formatele tipice de compresie și de arhivare a datelor sunt suportate în "
"mod direct de către module precum: :mod:`zlib`, :mod:`gzip`, :mod:`bz2`, "
":mod:`lzma`, :mod:`zipfile` și :mod:`tarfile`. ::"

#: ../../tutorial/stdlib.rst:242
msgid ""
">>> import zlib\n"
">>> s = b'witch which has which witches wrist watch'\n"
">>> len(s)\n"
"41\n"
">>> t = zlib.compress(s)\n"
">>> len(t)\n"
"37\n"
">>> zlib.decompress(t)\n"
"b'witch which has which witches wrist watch'\n"
">>> zlib.crc32(s)\n"
"226805979"
msgstr ""
">>> import zlib\n"
">>> șirul = b'arac brac capac colac copac crac drac fac lac mac tac'\\\n" 
"...         b' toc trac'\n"
">>> len(șirul)\n"
"62\n"
">>> șirul_comprimat = zlib.compress(șirul)\n"
">>> len(șirul_comprimat)\n"
"44\n"
">>> zlib.decompress(șirul_comprimat)\n"
"b'arac brac capac colac copac crac drac fac lac mac tac toc trac'\n"
">>> zlib.crc32(șirul)\n"
"2525718583"

#: ../../tutorial/stdlib.rst:258
msgid "Performance Measurement"
msgstr "Măsurarea performanțelor"

#: ../../tutorial/stdlib.rst:260
msgid ""
"Some Python users develop a deep interest in knowing the relative "
"performance of different approaches to the same problem. Python provides "
"a measurement tool that answers those questions immediately."
msgstr ""
"Nu de puține ori, programatorii se interesează de compararea "
"performanțelor pe care le dovedesc diferitele abordări (cunoscute) ale "
"aceleași probleme (de programare). Python-ul ne furnizează o unealtă de "
"măsurare (a timpului de execuție) care poate satisface rapid aceste "
"curiozități."

#: ../../tutorial/stdlib.rst:264
msgid ""
"For example, it may be tempting to use the tuple packing and unpacking "
"feature instead of the traditional approach to swapping arguments. The "
":mod:`timeit` module quickly demonstrates a modest performance "
"advantage::"
msgstr ""
"De exemplu, putem fi tentați, la un moment dat, să întrebuințăm "
"împachetarea și despachetarea tuplurilor în locul abordării tradiționale "
"la interschimbarea (de la englezescul *swapping*) unor valori. Modulul "
":mod:`timeit` ne dovedește imediat că folosirea tuplurilor ne va conferi "
"un mic avantaj::"

#: ../../tutorial/stdlib.rst:268
msgid ""
">>> from timeit import Timer\n"
">>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n"
"0.57535828626024577\n"
">>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n"
"0.54962537085770791"
msgstr ""
">>> from timeit import Timer\n"
">>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n"
"0.57535828626024577\n"
">>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n"
"0.54962537085770791"

#: ../../tutorial/stdlib.rst:274
msgid ""
"In contrast to :mod:`timeit`'s fine level of granularity, the "
":mod:`profile` and :mod:`pstats` modules provide tools for identifying "
"time critical sections in larger blocks of code."
msgstr ""
"Spre deosebire de nivelul de granularitate (ridicat) al lui :mod:`timeit`, "
"care îl face potrivit pe acesta pentru analiza unor fragmente mici de cod, "
"modulele :mod:`profile` și :mod:`pstats` posedă unelte pentru identificarea "
"zonelor critice în privința timpului de execuție din blocuri (mai) mari de "
"cod Python."

#: ../../tutorial/stdlib.rst:282
msgid "Quality Control"
msgstr "Controlul calității"

#: ../../tutorial/stdlib.rst:284
msgid ""
"One approach for developing high quality software is to write tests for "
"each function as it is developed and to run those tests frequently during"
" the development process."
msgstr ""
"Una din căile care ne conduc la producerea *software*-ului de înaltă "
"calitate este cea de *a compune teste* pentru verificarea fiecărei "
"*funcții* (funcționalități) pe parcursul implementării ei și de *a rula "
"aceste teste* în mod frecvent de-a lungul întregului proces de dezvoltare "
"a produsului software."

#: ../../tutorial/stdlib.rst:288
msgid ""
"The :mod:`doctest` module provides a tool for scanning a module and "
"validating tests embedded in a program's docstrings.  Test construction "
"is as simple as cutting-and-pasting a typical call along with its results"
" into the docstring. This improves the documentation by providing the "
"user with an example and it allows the doctest module to make sure the "
"code remains true to the documentation::"
msgstr ""
"Modulul :mod:`doctest` ne pune la dispoziție o unealtă care realizează "
"*analiza lexicală* a codului (sau "
"`scanarea <https://en.wikipedia.org/wiki/Lexical_analysis>`_; "
"de la englezescul *scanning*) unui modul și încearcă să *valideze testele* "
"care au fost inserate (de către autorii codului) în docstring-urile acestui "
"modul (program) Python. Prepararea unui asemenea test se rezumă la "
"decuparea-și-lipirea (de la englezescul *cut-and-paste*) în docstring a "
"fragmentului de cod format din apelul tipic al funcției (pe care vrem să o "
"verificăm) împreună cu rezultatul (corect) returnat de acest apel. Astfel, "
"pe de o parte, se îmbunătățește documentația oferindu-i-se utilizatorului "
"unul sau mai multe exemple și, pe de altă parte, existența respectivelor "
"fragmente îi va permite modulului *doctest* să verifice dacă programul pe "
"care utilizatorul îl dezvoltă îi rămâne fidel documentației (inițiale)::"

#: ../../tutorial/stdlib.rst:295
msgid ""
"def average(values):\n"
"    \"\"\"Computes the arithmetic mean of a list of numbers.\n"
"\n"
"    >>> print(average([20, 30, 70]))\n"
"    40.0\n"
"    \"\"\"\n"
"    return sum(values) / len(values)\n"
"\n"
"import doctest\n"
"doctest.testmod()   # automatically validate the embedded tests"
msgstr ""
">>> def media(valorile):\n"
"...     \"\"\"Calculează media aritmetică a unei liste de numere.\n"
"...\n"
"...     >>> print(media([20, 30, 70]))\n"
"...     40.0\n"
"...     \"\"\"\n"
"...     return sum(valorile) / len(valorile)\n"
"...\n"
">>> import doctest\n"
">>> doctest.testmod()   # validează automat testele incluse\n"
"TestResults(failed=0, attempted=1)"

#: ../../tutorial/stdlib.rst:306
msgid ""
"The :mod:`unittest` module is not as effortless as the :mod:`doctest` "
"module, but it allows a more comprehensive set of tests to be maintained "
"in a separate file::"
msgstr ""
"Modulul :mod:`unittest` nu este tot atât de fără efort la utilizare "
"precum :mod:`doctest`, însă ne permite să construim un set de teste (mai) "
"comprehensiv pe care să îl putem întreține într-un fișier separat::"

#: ../../tutorial/stdlib.rst:310
msgid ""
"import unittest\n"
"\n"
"class TestStatisticalFunctions(unittest.TestCase):\n"
"\n"
"    def test_average(self):\n"
"        self.assertEqual(average([20, 30, 70]), 40.0)\n"
"        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)\n"
"        with self.assertRaises(ZeroDivisionError):\n"
"            average([])\n"
"        with self.assertRaises(TypeError):\n"
"            average(20, 30, 70)\n"
"\n"
"unittest.main()  # Calling from the command line invokes all tests"
msgstr ""
"import unittest\n"
"\n"
"class TesteazăFuncțiileStatistice(unittest.TestCase):\n"
"\n"
"    def testează_media(self):\n"
"        self.assertEqual(media([20, 30, 70]), 40.0)\n"
"        self.assertEqual(round(media([1, 5, 7]), 1), 4.3)\n"
"        with self.assertRaises(ZeroDivisionError):\n"
"            media([])\n"
"        with self.assertRaises(TypeError):\n"
"            media(20, 30, 70)\n"
"\n"
"unittest.main()  # La apelul în linia de comandă vor fi invocate\n"
"                 # toate testele"

#: ../../tutorial/stdlib.rst:328
msgid "Batteries Included"
msgstr "Bateriile sunt incluse"

#: ../../tutorial/stdlib.rst:330
msgid ""
"Python has a \"batteries included\" philosophy.  This is best seen "
"through the sophisticated and robust capabilities of its larger packages."
" For example:"
msgstr ""
"Python-ul urmează filozofia \"includeți (și) bateriile\". Putem observa "
"cu ușurință aceasta dacă aruncăm o privire asupra capabilităților robuste "
"și sofisticate pe care le probează pachetele sale cele mai cuprinzătoare. "
"De pildă:"

#: ../../tutorial/stdlib.rst:333
msgid ""
"The :mod:`xmlrpc.client` and :mod:`xmlrpc.server` modules make "
"implementing remote procedure calls into an almost trivial task.  Despite"
" the modules' names, no direct knowledge or handling of XML is needed."
msgstr ""
"Modulele :mod:`xmlrpc.client` și :mod:`xmlrpc.server` transformă orice "
"implementare de `apeluri de procedură de la distanță "
"<https://en.wikipedia.org/wiki/Remote_procedure_call>`_ într-o activitate "
"aproape banală. În ciuda numelor acestor module, nu este nevoie nici de "
"cunoștințe teoretice și nici de experință practică privind XML-ul."

#: ../../tutorial/stdlib.rst:337
msgid ""
"The :mod:`email` package is a library for managing email messages, "
"including MIME and other :rfc:`2822`-based message documents. Unlike "
":mod:`smtplib` and :mod:`poplib` which actually send and receive "
"messages, the email package has a complete toolset for building or "
"decoding complex message structures (including attachments) and for "
"implementing internet encoding and header protocols."
msgstr ""
"Pachetul :mod:`email` este o bibliotecă dedicată administrării "
"mesajelor de poștă electronică, inclusiv a mesageriei documentelor "
"MIME și a altor documente bazate pe :rfc:`2822`. Spre deosebire de "
":mod:`smtplib` și de :mod:`poplib`, care trimit și primesc efectiv "
"mesajele, pachetul *email* deține un set complet de instrumente pentru "
"construcția și decodificarea structurilor complexe de mesaje (incluzând "
"aici și *anexele*, de la englezescul *attachment*, acestor mesaje), "
"respectiv pentru implementarea protocoalelor de Internet privind "
"codificările (textului) și antetele (mesajelor)."

#: ../../tutorial/stdlib.rst:344
msgid ""
"The :mod:`json` package provides robust support for parsing this popular "
"data interchange format.  The :mod:`csv` module supports direct reading "
"and writing of files in Comma-Separated Value format, commonly supported "
"by databases and spreadsheets.  XML processing is supported by the "
":mod:`xml.etree.ElementTree`, :mod:`xml.dom` and :mod:`xml.sax` packages."
" Together, these modules and packages greatly simplify data interchange "
"between Python applications and other tools."
msgstr ""
"Pachetul :mod:`json` oferă suport robust pentru *analiza sintactică și "
"semantică* a codului (sau "
"`parsarea <https://en.wikipedia.org/wiki/Compiler>`_; de la englezescul "
"*parsing*) acestui format popular de interschimbare de date. Modulul "
":mod:`csv` ne permite citirea și scrierea directă a fișierelor în "
"formatul *valori-separate-prin-virgule* (sau *valori-delimitate-de-"
"virgule*; de la englezescul *comma-separated-value*), format acceptat de "
"majoritatea bazelor de date și a foilor de calcul (de la englezescul "
"*spreadsheet*). Procesările XML sunt suportate de pachetele "
":mod:`xml.etree.ElementTree`, :mod:`xml.dom` și :mod:`xml.sax`. "
"Laolaltă, aceste module și pachete ușurează considerabil schimburile de "
"date dintre aplicațiile Python și alte unelte informatice."

#: ../../tutorial/stdlib.rst:353
msgid ""
"The :mod:`sqlite3` module is a wrapper for the SQLite database library, "
"providing a persistent database that can be updated and accessed using "
"slightly nonstandard SQL syntax."
msgstr ""
"Modulul :mod:`sqlite3` este o împachetare a bibliotecii de baze de date "
"SQLite, care ne pune la dispoziție o bază de date persistentă (pe *disc*) "
"ce va putea fi actualizată și accesată folosind o sintaxă SQL puțin "
"atipică."


#: ../../tutorial/stdlib.rst:357
msgid ""
"Internationalization is supported by a number of modules including "
":mod:`gettext`, :mod:`locale`, and the :mod:`codecs` package."
msgstr ""
"`Internaționalizarea <https://en.wikipedia.org/wiki/"
"Internationalization_and_localization>`_ este facilitată de un număr de "
"module, incluzându-le aici pe :mod:`gettext`, :mod:`locale`, precum și "
"de pachetul :mod:`codecs`."

#: ../../tutorial/stdlib.rst:27
msgid "built-in function"
msgstr "funcție predefinită"

#: ../../tutorial/stdlib.rst:27
msgid "help"
msgstr "ajutor"

