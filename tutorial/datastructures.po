# STRUCTURI DE DATE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Octavian Mustafa <octawian@yahoo.com>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-17 17:56+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ro\n"
"Language-Team: ro <octawian@yahoo.com>\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : (n==0 || (n%100 > 0 && n%100"
" < 20)) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "Structuri de date"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"Capitolul de față se apleacă mai în detaliu asupra unor chestiuni "
"cu care v-ați întâlnit deja, iar acestora le adaugă, firește, și "
"lucruri noi."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "Mai multe despre liste"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of"
" list objects:"
msgstr ""
"Tipul de date listă dispune de mai multe metode. Iată toate aceste metode "
"ale obiectelor listă:"

#: ../../tutorial/datastructures.rst:22
msgid "Add an item to the end of the list.  Similar to ``a[len(a):] = [x]``."
msgstr ""
"Adaugă un element la finalul listei. La fel ca ``a[len(a):] = [x]``."

#: ../../tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Similar to"
" ``a[len(a):] = iterable``."
msgstr ""
"Extinde lista prin adăugarea tuturor elementelor unui (obiect) iterabil. "
"La fel ca ``a[len(a):] = iterabil``."

#: ../../tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of "
"the element before which to insert, so ``a.insert(0, x)`` inserts at the "
"front of the list, and ``a.insert(len(a), x)`` is equivalent to "
"``a.append(x)``."
msgstr ""
"Inserează un element la poziția dată. Primul argument este indicele "
"elementului înaintea căruia se va face inserția, de aceea "
"``a.insert(0, x)`` va realiza o inserție la începutul listei în timp ce "
"``a.insert(len(a), x)`` este echivalentă cu ``a.append(x)``."

#: ../../tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It "
"raises a :exc:`ValueError` if there is no such item."
msgstr ""
"Elimină primul element din listă a cărui valoare este egală cu *x*. Va "
"ridica o excepție :exc:`ValueError` dacă nu există niciun astfel de "
"element."

#: ../../tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is"
" outside the list range."
msgstr ""
"Elimină din listă elementul de la poziția dată și îl returnează. Dacă "
"nu se specifică indicele elementului, atunci ``a.pop()`` va elimina și va "
"returna ultimul element al listei. Ridică o excepție :exc:`IndexError` "
"atunci când fie lista este goală fie când indicele se găsește în afara "
"plajei de valori a indicilor elementelor listei."

#: ../../tutorial/datastructures.rst:59
msgid "Remove all items from the list.  Similar to ``del a[:]``."
msgstr "Elimină toate elementele din listă. La fel ca ``del a[:]``."

#: ../../tutorial/datastructures.rst:65
msgid ""
"Return zero-based index in the list of the first item whose value is "
"equal to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"Întoarce indicele, numerotat de la zero, al primului element al listei "
"a cărui valoare este egală cu *x*. Ridică o excepție :exc:`ValueError` "
"dacă nu există niciun asemenea element."

#: ../../tutorial/datastructures.rst:68
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of "
"the list.  The returned index is computed relative to the beginning of "
"the full sequence rather than the *start* argument."
msgstr ""
"Argumentele opționale *start* și *end* sunt interpretate la fel ca în "
"cazul unei felieri și sunt folosite la limitarea căutărilor într-o "
"anumită sub-secvență a listei. Indicele returnat se calculează relativ "
"la începutul întregii secvențe și nu începând de la argumentul *start*."

#: ../../tutorial/datastructures.rst:77
msgid "Return the number of times *x* appears in the list."
msgstr "Returnează numărul de apariții ale lui *x* în listă."

#: ../../tutorial/datastructures.rst:83
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Sortează elementele listei păstrându-le în aceeași listă (argumentele "
"pot fi folosite la construcția unei sortări personalizate, vezi "
":func:`sorted` pentru o justificare a lor)."

#: ../../tutorial/datastructures.rst:90
msgid "Reverse the elements of the list in place."
msgstr ""
"Scrie în ordine inversă elementele listei păstrându-le în aceeași "
"listă."

#: ../../tutorial/datastructures.rst:96
msgid "Return a shallow copy of the list.  Similar to ``a[:]``."
msgstr ""
"Întoarce o copie superficială a listei. La fel ca ``a[:]``."

#: ../../tutorial/datastructures.rst:99
msgid "An example that uses most of the list methods::"
msgstr "Un exemplu care întrebuințează majoritatea metodelor listei::"

#: ../../tutorial/datastructures.rst:101
msgid ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']"
"\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']"
"\n"
">>> fruits.pop()\n"
"'pear'"
msgstr ""
">>> fructe = ['portocală', 'măr', 'pară', 'banană', 'kiwi', 'măr', "
"'banană']\n"
">>> fructe.count('măr')\n"
"2\n"
">>> fructe.count('mandarină')\n"
"0\n"
">>> fructe.index('banană')\n"
"3\n"
">>> fructe.index('banană', 4)  # Găsește prima banană situată la dreapta "
"poziției 4\n"
"6\n"
">>> fructe.reverse()\n"
">>> fructe\n"
"['banană', 'măr', 'kiwi', 'banană', 'pară', 'măr', 'portocală']\n"
">>> fructe.append('struguri')\n"
">>> fructe\n"
"['banană', 'măr', 'kiwi', 'banană', 'pară', 'măr', 'portocală', 'struguri']"
"\n"
">>> fructe.sort()\n"
">>> fructe\n"
"['banană', 'banană', 'kiwi', 'măr', 'măr', 'pară', 'portocală', 'struguri']"
"\n"
">>> fructe.pop()\n"
"'struguri'"

#: ../../tutorial/datastructures.rst:122
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or "
"``sort`` that only modify the list have no return value printed -- they "
"return the default ``None``. [#]_  This is a design principle for all "
"mutable data structures in Python."
msgstr ""
"Poate că ați remarcat deja că metode precum ``insert``, ``remove`` sau "
"``sort``, adică metode care fac modificări în listă păstrând lista, nu "
"afișează nicio valoare returnată -- în fapt, ele returnează valoarea "
"prestabilită ``None``. [#]_  Acesta este un principiu de design valabil "
"pentru toate structurile de date mutabile din Python."

#: ../../tutorial/datastructures.rst:127
msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and ``None`` can't be compared to "
"other types.  Also, there are some types that don't have a defined "
"ordering relation.  For example, ``3+4j < 5+7j`` isn't a valid "
"comparison."
msgstr ""
"Altă chestiune de remarcat este aceea că nu toate datele pot fi sortate "
"și nici comparate. De exemplu, ``[None, 'salut', 10]`` nu se va sorta "
"deoarece numerele întregi nu sunt comparabile cu șirurile de "
"caractere iar ``None`` nu poate fi comparat cu niciun alt tip de date. "
"De asemeni, există tipuri de date fără o relație de ordine "
"`totală <https://en.wikipedia.org/wiki/Total_order>`_. Astfel, "
"``3+4j < 5+7j`` nu este o comparație validă."

#: ../../tutorial/datastructures.rst:138
msgid "Using Lists as Stacks"
msgstr "Utilizarea listelor ca stive"

#: ../../tutorial/datastructures.rst:143
msgid ""
"The list methods make it very easy to use a list as a stack, where the "
"last element added is the first element retrieved (\"last-in, first-"
"out\").  To add an item to the top of the stack, use :meth:`!append`.  To"
" retrieve an item from the top of the stack, use :meth:`!pop` without an "
"explicit index.  For example::"
msgstr ""
"Metodele tipului listă ne permit să utilizăm listele cu ușurință pe post "
"de stive, adică de instanțe ale acelui tip de date la care ultimul element "
"adăugat va fi extras primul (\"ultimul intrat, primul ieșit\"). Pentru "
"a pune un element în vârful stivei, folosiți :meth:`!append`. Pentru a "
"scoate un element din vârful stivei, folosiți :meth:`!pop` fără să "
"precizați niciun index. De exemplu::"

#: ../../tutorial/datastructures.rst:148
msgid ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"
msgstr ""
">>> stiva = [3, 4, 5]\n"
">>> stiva.append(6)\n"
">>> stiva.append(7)\n"
">>> stiva\n"
"[3, 4, 5, 6, 7]\n"
">>> stiva.pop()\n"
"7\n"
">>> stiva\n"
"[3, 4, 5, 6]\n"
">>> stiva.pop()\n"
"6\n"
">>> stiva.pop()\n"
"5\n"
">>> stiva\n"
"[3, 4]"

#: ../../tutorial/datastructures.rst:168
msgid "Using Lists as Queues"
msgstr "Făcând cozi din liste"

#: ../../tutorial/datastructures.rst:172
msgid ""
"It is also possible to use a list as a queue, where the first element "
"added is the first element retrieved (\"first-in, first-out\"); however, "
"lists are not efficient for this purpose.  While appends and pops from "
"the end of list are fast, doing inserts or pops from the beginning of a "
"list is slow (because all of the other elements have to be shifted by "
"one)."
msgstr ""
"Se poate să întrebuințăm o listă aidoma unei cozi, adică a unei instanțe "
"a acelui tip de date la care primul element adăugat va fi extras primul "
"(\"primul intrat, primul ieșit\"); însă listele nu au fost proiectate ca "
"să fie eficiente în acest scop. În timp ce adăugările la final și "
"extragerile de la finalul unei liste sunt rapide, realizarea de inserări "
"la început și de eliminări de la începutul unei liste sunt operații lente "
"(aceasta deoarece toate celelalte elemente trebuie deplasate în lateral "
"cu câte o poziție)." 

#: ../../tutorial/datastructures.rst:178
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed "
"to have fast appends and pops from both ends.  For example::"
msgstr ""
"Pentru a implementa o coadă, folosiți :class:`collections.deque` care a "
"fost proiectată special ca să realizeze adăugiri și eliminări rapide la "
"ambele capete. De exemplu::"

#: ../../tutorial/datastructures.rst:181
msgid ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival"
"\n"
"deque(['Michael', 'Terry', 'Graham'])"
msgstr ""
">>> from collections import deque\n"
">>> coadă = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> coadă.append(\"Terry\")      # Terry intră în scenă\n"
">>> coadă.append(\"Graham\")     # Graham intră în scenă\n"
">>> coadă.popleft()            # Primul sosit iese din scenă\n"
"'Eric'\n"
">>> coadă.popleft()            # Al doilea sosit iese din scenă\n"
"'John'\n"
">>> coadă                      # Coada rămasă, în ordinea " 
"intrărilor în scenă\n"
"\n"
"deque(['Michael', 'Terry', 'Graham'])"

#: ../../tutorial/datastructures.rst:196
msgid "List Comprehensions"
msgstr "Comprehensiunea listelor"

#: ../../tutorial/datastructures.rst:198
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of "
"some operations applied to each member of another sequence or iterable, "
"or to create a subsequence of those elements that satisfy a certain "
"condition."
msgstr ""
"Comprehensiunea listelor (*înțelegerea* dar și *explicarea* lor) reprezintă "
"o metodă succintă de a crea liste. Aplicațiile esențiale ale acesteia "
"sunt construcțiile de liste noi ale căror elemente să fie rezultatul "
"realizării anumitor operații cu fiecare din membrii unei secvențe ori "
"ai unui iterabil, respectiv crearea unei sub-secvențe din acele "
"elemente ale unei secvențe date care îndeplinesc o anumită condiție."

#: ../../tutorial/datastructures.rst:203
msgid "For example, assume we want to create a list of squares, like::"
msgstr ""
"De exemplu, să presupunem că dorim să creăm o listă de pătrate perfecte, "
"precum urmează::"

#: ../../tutorial/datastructures.rst:205
msgid ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> pătrate_perfecte = []\n"
">>> for x in range(10):\n"
"...     pătrate_perfecte.append(x**2)\n"
"...\n"
">>> pătrate_perfecte\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

#: ../../tutorial/datastructures.rst:212
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Să remarcăm că procedeul anterior creează (ori suprascrie) o variabilă "
"numită ``x`` care va exista și după încheierea ciclului :keyword:`!for`. "
"Putem calcula lista pătratelor perfecte și fără asemenea efecte "
"secundare dacă utilizăm fie expresia::"

#: ../../tutorial/datastructures.rst:216
msgid "squares = list(map(lambda x: x**2, range(10)))"
msgstr "pătrate_perfecte = list(map(lambda x: x**2, range(10)))"

#: ../../tutorial/datastructures.rst:218
msgid "or, equivalently::"
msgstr "fie pe cea echivalentă acesteia::"

#: ../../tutorial/datastructures.rst:220
msgid "squares = [x**2 for x in range(10)]"
msgstr "pătrate_perfecte = [x**2 for x in range(10)]"

#: ../../tutorial/datastructures.rst:222
msgid "which is more concise and readable."
msgstr "care este mai concisă și mai ușor de citit."

#: ../../tutorial/datastructures.rst:224
msgid ""
"A list comprehension consists of brackets containing an expression "
"followed by a :keyword:`!for` clause, then zero or more :keyword:`!for` "
"or :keyword:`!if` clauses.  The result will be a new list resulting from "
"evaluating the expression in the context of the :keyword:`!for` and "
":keyword:`!if` clauses which follow it. For example, this listcomp "
"combines the elements of two lists if they are not equal::"
msgstr ""
"Comprehensiunea unei liste constă din paranteze drepte care încadrează "
"o expresie urmată de o clauză :keyword:`!for`, apoi de zero sau mai "
"multe clauze :keyword:`!for` ori clauze :keyword:`!if`. Rezultatul "
"comprehensiunii va fi o listă nouă, produsă ca urmare a evaluării "
"expresiei în contextul clauzelor :keyword:`!for` și :keyword:`!if` "
"care îi urmează în cod. De exemplu, următoarea comprehensiune de "
"liste (în englezește, ca jargon, *listcomp*) combină elementele a "
"două liste atunci când aceste elemente nu sunt egale::"

#: ../../tutorial/datastructures.rst:231
msgid ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:234
msgid "and it's equivalent to::"
msgstr "și este echivalentă cu::"

#: ../../tutorial/datastructures.rst:236
msgid ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> combinații = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combinații.append((x, y))\n"
"...\n"
">>> combinații\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:245
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is "
"the same in both these snippets."
msgstr ""
"Remarcați că ordinea instrucțiunilor :keyword:`for` și :keyword:`if` se "
"păstrează în ambele fragmente de cod."

#: ../../tutorial/datastructures.rst:248
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous "
"example), it must be parenthesized. ::"
msgstr ""
"Dacă expresia este un tuplu (precum ``(x, y)``-ul din exemplul "
"precedent), atunci ea trebuie încadrată de paranteze. ::"

#: ../../tutorial/datastructures.rst:251
msgid ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # create a new list with the values doubled\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # flatten a list using a listcomp with two 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""
">>> vectorul = [-4, -2, 0, 2, 4]\n"
">>> # crearea unei liste noi cu valoarea elementelor dublată\n"
">>> [x*2 for x in vectorul]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filtrarea listei pentru a exclude numerele negative\n"
">>> [x for x in vectorul if x >= 0]\n"
"[0, 2, 4]\n"
">>> # aplicarea unei funcții fiecărui element din listă\n"
">>> [abs(x) for x in vectorul]\n"
"[4, 2, 0, 2, 4]\n"
">>> # apelul unei metode a fiecărui element din listă\n"
">>> fructe_proaspete = ['  banană', '  hibrid de mure și zmeură ', "
"'fructul pasiunii  ']\n"
">>> [armă.strip() for armă in fructe_proaspete]\n"
"['banană', 'hibrid de mure și zmeură', 'fructul pasiunii']\n"
">>> # crearea unei liste de 2-tupluri de felul (numărul, pătratul său)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # tuplul trebuie încadrat de paranteze, în caz contrar producându-se "
"o eroare\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # serializarea unei liste folosind o listcomp cu două 'for'-uri\n"
">>> vectorul = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [numărul for elementul in vectorul for numărul in elementul]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"

#: ../../tutorial/datastructures.rst:279
msgid "List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"Comprehensiunile de liste pot conține atât expresii complexe cât și funcții "
"imbricate::"

#: ../../tutorial/datastructures.rst:281
msgid ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"
msgstr ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"

#: ../../tutorial/datastructures.rst:286
msgid "Nested List Comprehensions"
msgstr "Comprehensiuni imbricate de liste"

#: ../../tutorial/datastructures.rst:288
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"Expresia inițială dintr-o comprehensiune de liste poate fi orice fel "
"de expresie, deci poate include și o (altă) comprehensiune de liste."

#: ../../tutorial/datastructures.rst:291
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3"
" lists of length 4::"
msgstr ""
"Să luăm în considerare următorul exemplu de matrice 3x4 implementată ca "
"listă formată din 3 liste de lungime 4::"

#: ../../tutorial/datastructures.rst:294
msgid ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"
msgstr ""
">>> matrice = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"

#: ../../tutorial/datastructures.rst:300
msgid "The following list comprehension will transpose rows and columns::"
msgstr ""
"Comprehensiunea de liste care urmează va "
"`transpune <https://en.wikipedia.org/wiki/Transpose>`_ "
"liniile și coloanele matricei::"

#: ../../tutorial/datastructures.rst:302
msgid ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> [[linia[i] for linia in matrice] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:305
msgid ""
"As we saw in the previous section, the inner list comprehension is "
"evaluated in the context of the :keyword:`for` that follows it, so this "
"example is equivalent to::"
msgstr ""
"Așa cum am văzut în secțiunea anterioară, comprehensiunea listei "
"interioare este evaluată în contextul :keyword:`for`-ul care îi "
"urmează listei, așa că exemplul de cod este echivalent cu::"

#: ../../tutorial/datastructures.rst:309
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transpusa = []\n"
">>> for i in range(4):\n"
"...     transpusa.append([linia[i] for linia in matrice])\n"
"...\n"
">>> transpusa\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:316
msgid "which, in turn, is the same as::"
msgstr "cod care, la rândul său, este identic cu::"

#: ../../tutorial/datastructures.rst:318
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transpusa = []\n"
">>> for i in range(4):\n"
"...     # următoarele 3 linii de cod implementează listcomp-a imbricată\n"
"...     linia_transpusei = []\n"
"...     for linia in matrice:\n"
"...         linia_transpusei.append(linia[i])\n"
"...     transpusa.append(linia_transpusei)\n"
"...\n"
">>> transpusa\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:329
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use "
"case::"
msgstr ""
"În lumea reală, preferați funcțiile predefinite oricăror instrucțiuni "
"iterative complexe. Funcția :func:`zip` s-ar descurca de minune "
"în cazul de întrebuințare pe care îl studiem::"

#: ../../tutorial/datastructures.rst:332
msgid ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
msgstr ""
">>> list(zip(*matrice))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"

#: ../../tutorial/datastructures.rst:335
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this "
"line."
msgstr ""
"A se vedea :ref:`tut-unpacking-arguments` pentru detalii despre asteriscul "
"de pe această linie de cod."

#: ../../tutorial/datastructures.rst:340
msgid "The :keyword:`!del` statement"
msgstr "Instrucțiunea :keyword:`!del`"

#: ../../tutorial/datastructures.rst:342
msgid ""
"There is a way to remove an item from a list given its index instead of "
"its value: the :keyword:`del` statement.  This differs from the "
":meth:`!pop` method which returns a value.  The :keyword:`!del` statement"
" can also be used to remove slices from a list or clear the entire list "
"(which we did earlier by assignment of an empty list to the slice).  For "
"example::"
msgstr ""
"Există o modalitate de a elimina un element dintr-o listă atunci când îi "
"știm indicele (poziția) dar nu și valoarea: instrucțiunea :keyword:`del`. "
"Aceasta diferă de metoda :meth:`!pop` care returnează valoarea elementului "
"eliminat. Instrucțiunea :keyword:`!del` poate fi utilizată și la "
"eliminarea de felii din listă ori la golirea întregii liste (ceea ce am "
"făcut anterior atribuindu-i feliei o listă goală). De exemplu::"

#: ../../tutorial/datastructures.rst:348
msgid ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"
msgstr ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"

#: ../../tutorial/datastructures.rst:359
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ""
":keyword:`del` poate fi folosită și la ștergerea completă a unei "
"variabile::"

#: ../../tutorial/datastructures.rst:361
msgid ">>> del a"
msgstr ">>> del a"

#: ../../tutorial/datastructures.rst:363
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` "
"later."
msgstr ""
"Referențierea numelui ``a`` de acum înainte este eronată (cel puțin până "
"când acestui nume îi vom atribui o valoare). Îi vom găsi ulterior și "
"alte întrebuințări lui :keyword:`del`."

#: ../../tutorial/datastructures.rst:370
msgid "Tuples and Sequences"
msgstr "Tupluri și secvențe"

#: ../../tutorial/datastructures.rst:372
msgid ""
"We saw that lists and strings have many common properties, such as "
"indexing and slicing operations.  They are two examples of *sequence* "
"data types (see :ref:`typesseq`).  Since Python is an evolving language, "
"other sequence data types may be added.  There is also another standard "
"sequence data type: the *tuple*."
msgstr ""
"Am văzut că șirurile de caractere și listele au multe proprietăți în "
"comun, cum ar fi operațiile de indexare și de feliere. Tipurile acestor "
"obiecte sunt exemple de tipuri de date *secvență* (vezi :ref:`typesseq`). "
"Deoarece Python-ul este un limbaj aflat în plină evoluție, se poate ca și "
"alte tipuri secvență de date să îi fie adăugate. Mai există un tip "
"secvență de date standard: *tuplul*."

#: ../../tutorial/datastructures.rst:378
msgid "A tuple consists of a number of values separated by commas, for instance::"
msgstr "Un tuplu constă dintr-un număr de valori separate prin virgulă, cum "
"ar fi::"

#: ../../tutorial/datastructures.rst:380
msgid ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # Tuples may be nested:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # Tuples are immutable:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # but they can contain mutable objects:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"
msgstr ""
">>> t = 12345, 54321, 'salut!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'salut!')\n"
">>> # Tuplurile pot fi imbricate:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'salut!'), (1, 2, 3, 4, 5))\n"
">>> # Tuplurile sunt imutabile:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # însă pot conține obiecte mutabile:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"

#: ../../tutorial/datastructures.rst:400
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or "
"without surrounding parentheses, although often parentheses are necessary"
" anyway (if the tuple is part of a larger expression).  It is not "
"possible to assign to the individual items of a tuple, however it is "
"possible to create tuples which contain mutable objects, such as lists."
msgstr ""
"După cum puteți observa, atunci când sunt afișate, tuplurile apar "
"întotdeauna încadrate de paranteze, drept pentru care tuplurile "
"imbricate vor putea fi interpretate corect; pe de altă parte, ele pot fi "
"introduse cu sau fără paranteze, chiar dacă adesea parantezele sunt "
"necesare (atunci când tuplul face parte dintr-o expresie mai "
"cuprinzătoare). Deși nu îi putem atribui valori niciunui element "
"individual al unui tuplu, putem crea tupluri care conțin obiecte "
"mutabile, precum listele."

#: ../../tutorial/datastructures.rst:407
msgid ""
"Though tuples may seem similar to lists, they are often used in different"
" situations and for different purposes. Tuples are :term:`immutable`, and"
" usually contain a heterogeneous sequence of elements that are accessed "
"via unpacking (see later in this section) or indexing (or even by "
"attribute in the case of :func:`namedtuples <collections.namedtuple>`). "
"Lists are :term:`mutable`, and their elements are usually homogeneous and"
" are accessed by iterating over the list."
msgstr ""
"Chiar dacă tuplurile par să semene cu listele, ele se folosesc adesea în "
"situații diferite și pentru scopuri diferite de cele ale utilizării "
"listelor. Tuplurile sunt :term:`immutable` și conțin, de obicei, o "
"secvență eterogenă de elemente care pot fi accesate fie via despachetare "
"(după cum vom vedea ulterior în secțiunea de față) fie prin indexare (ba "
"chiar și prin intermediul atributelor în cazul "
":func:`namedtuples <collections.namedtuple>`). În schimb, listele sunt "
":term:`mutable` iar elementele unei liste sunt omogene, de obicei, și se "
"accesează prin iterări de-a lungul listei."

#: ../../tutorial/datastructures.rst:415
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: "
"the syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For "
"example::"
msgstr ""
"O problemă aparte o constituie construcția de tupluri cu 0 sau 1 elemente: "
"sintaxa impune câteva adaosuri ciudate pentru a le acomoda. Astfel, "
"tuplurile goale se construiesc cu o pereche goală de paranteze rotunde; "
"un tuplu cu un singur element este construit dintr-o valoare urmată de "
"o virgulă (nu este suficient să încadrăm valoarea între paranteze). "
"Neplăcut, dar eficient. Ca, de exemplu::"

#: ../../tutorial/datastructures.rst:421
msgid ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"
msgstr ""
">>> gol = ()\n"
">>> singular = 'salut',    # <-- remarcați virgula de final\n"
">>> len(gol)\n"
"0\n"
">>> len(singular)\n"
"1\n"
">>> singular\n"
"('salut',)"

#: ../../tutorial/datastructures.rst:430
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"Instrucțiunea ``t = 12345, 54321, 'salut!'`` este un exemplu de "
"*împachetare în tuplu*: valorile ``12345``, ``54321`` și "
"``'salut!'`` sunt puse laolaltă într-un tuplu. Este posibilă și "
"operația inversă::"

#: ../../tutorial/datastructures.rst:434
msgid ">>> x, y, z = t"
msgstr ">>> x, y, z = t"

#: ../../tutorial/datastructures.rst:436
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for "
"any sequence on the right-hand side.  Sequence unpacking requires that "
"there are as many variables on the left side of the equals sign as there "
"are elements in the sequence.  Note that multiple assignment is really "
"just a combination of tuple packing and sequence unpacking."
msgstr ""
"Aceasta se numește, destul de potrivit, *despachetarea secvenței* și "
"funcționează pentru orice secvență admisă ca valoare de pe partea dreaptă "
"(ori "
"`r-valoare <https://en.wikipedia.org/wiki/Value_(computer_science)>`_). "
"Despachetarea secvențelor cere să fie tot atâtea variabile pe partea "
"stângă a semnului egal câte elemente are secvența. Să observăm că "
"atribuirea multiplă este, în realitate, doar o combinație de împachetări "
"de tupluri și de despachetări de secvențe."

#: ../../tutorial/datastructures.rst:446
msgid "Sets"
msgstr "Seturi"

#: ../../tutorial/datastructures.rst:448
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and "
"symmetric difference."
msgstr ""
"Python-ul posedă și un tip de date pentru tratamentul *mulțimilor* (al "
"*seturilor*). Un set este o colecție neordonată de elemente, fără "
"duplicate. Întrebuințările de bază ale acestui tip de date includ "
"verificarea apartenenței și eliminarea duplicatelor de elemente. "
"Obiectele mulțime suportă, de asemeni, și operații matematice precum "
"reuniunea, intersecția, diferența ori diferența simetrică."

#: ../../tutorial/datastructures.rst:453
#, python-brace-format
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  "
"Note: to create an empty set you have to use ``set()``, not ``{}``; the "
"latter creates an empty dictionary, a data structure that we discuss in "
"the next section."
msgstr ""
"Atât acoladele cât și funcția :func:`set` pot fi folosite la crearea de "
"mulțimi. Remarcă: pentru a crea o mulțime vidă trebuie să utilizați "
"``set()``, nu ``{}``; cea din urmă formulă va construi un dicționar de "
"date gol, iar despre o asemenea structură de date vom discuta în secțiunea "
"următoare."

#: ../../tutorial/datastructures.rst:457
msgid "Here is a brief demonstration::"
msgstr "Iată o scurtă demonstrație::"

#: ../../tutorial/datastructures.rst:459
#, python-brace-format
msgid ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # show that duplicates have been "
"removed\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # fast membership testing\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # Demonstrate set operations on unique letters from two words\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # unique letters in a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # letters in a but not in b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # letters in a or b or both\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # letters in both a and b\n"
"{'a', 'c'}\n"
">>> a ^ b                              # letters in a or b but not both\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"
msgstr ""
">>> coș = {'măr', 'portocală', 'măr', 'pară', 'portocală', 'banană'}\n"
">>> print(coș)               # arată că duplicatele au fost "
"eliminate\n"
"{'portocală', 'banană', 'pară', 'măr'}\n"
">>> 'portocală' in coș       # testarea rapidă a apartenenței\n"
"True\n"
">>> 'pălămidă' in coș\n"
"False\n"
"\n"
">>> # Demonstrarea operațiilor cu mulțimi într-o problemă\n"
">>> # privind literele unicat din două cuvinte\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                        # litere unicat în a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                    # literele care sunt în a dar "
"nu sunt în b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                    # literele care sunt sau în a "
"sau în b sau în amândouă\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                    # literele care sunt și în a și "
"în b\n"
"{'a', 'c'}\n"
">>> a ^ b                    # literele care sunt sau în a sau "
"în b dar nu în amândouă\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"

#: ../../tutorial/datastructures.rst:482
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set "
"comprehensions are also supported::"
msgstr ""
"Asemănător :ref:`comprehensiunii listelor <tut-listcomps>`, sunt permise "
"și comprehensiunile de mulțimi::"

#: ../../tutorial/datastructures.rst:485
#, python-brace-format
msgid ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"
msgstr ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"

#: ../../tutorial/datastructures.rst:493
msgid "Dictionaries"
msgstr "Dicționare de date"

#: ../../tutorial/datastructures.rst:495
msgid ""
"Another useful data type built into Python is the *dictionary* (see "
":ref:`typesmapping`). Dictionaries are sometimes found in other languages"
" as \"associative memories\" or \"associative arrays\".  Unlike "
"sequences, which are indexed by a range of numbers, dictionaries are "
"indexed by *keys*, which can be any immutable type; strings and numbers "
"can always be keys.  Tuples can be used as keys if they contain only "
"strings, numbers, or tuples; if a tuple contains any mutable object "
"either directly or indirectly, it cannot be used as a key. You can't use "
"lists as keys, since lists can be modified in place using index "
"assignments, slice assignments, or methods like :meth:`!append` and "
":meth:`!extend`."
msgstr ""
"Alt tip de date util, predefinit în Python, este *dicționarul* (de date, "
"vezi :ref:`typesmapping`). Dicționare de date se găsesc și în alte "
"limbaje de programare, numite uneori \"memorii asociative\" ori "
"\"tablouri asociative\" (de la englezescul *array*). Spre deosebire de "
"secvențe, ale căror elemente sunt indexate cu indici dintr-un domeniu "
"de valori numerice, dicționarele de date au elementele indexate cu "
"*chei*, acestea putând fi obiecte ale oricărui tip de date imutabile."

#: ../../tutorial/datastructures.rst:506
#, python-brace-format
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with "
"the requirement that the keys are unique (within one dictionary). A pair "
"of braces creates an empty dictionary: ``{}``. Placing a comma-separated "
"list of key:value pairs within the braces adds initial key:value pairs to"
" the dictionary; this is also the way dictionaries are written on output."
msgstr ""
"Cel mai bine este să ne gândim la dicționarul de date ca la o mulțime de "
"perechi *cheie: valoare* pentru care se cere să avem chei unice (într-un "
"singur dicționar). O pereche de acolade creează un dicționar gol: "
"``{}``. Plasând o listă de perechi cheie:valoare cu elementele separate "
"prin virgule între aceste acolade, vom adăuga perechile cheie:valoare "
"din listă la dicționarul de date; acesta este, de fapt, modul în care "
"dicționarele sunt afișate."

#: ../../tutorial/datastructures.rst:512
msgid ""
"The main operations on a dictionary are storing a value with some key and"
" extracting the value given the key.  It is also possible to delete a "
"key:value pair with ``del``. If you store using a key that is already in "
"use, the old value associated with that key is forgotten.  It is an error"
" to extract a value using a non-existent key."
msgstr ""
"Operațiile principale pe care le realizăm asupra unui dicționar sunt "
"inserarea unei valori cu ajutorul unei anumite chei și extragerea unei "
"valori căreia îi știm cheia. Este, de asemeni, posibil să elimnăm o "
"pereche cheie:valoare cu ajutorul lui ``del``. Dacă inserăm o valoare "
"folosind o cheie care a fost deja asociată unei anumite valori, atunci "
"vechea valoare se va pierde. Încercarea de a extrage o valoare folosind "
"o cheie inexistentă va produce o eroare."

#: ../../tutorial/datastructures.rst:518
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys "
"used in the dictionary, in insertion order (if you want it sorted, just "
"use ``sorted(d)`` instead). To check whether a single key is in the "
"dictionary, use the :keyword:`in` keyword."
msgstr ""
"Executând instrucțiunea ``list(d)`` asupra unui dicționar de date ``d``, "
"se va returna lista tuturor cheilor utilizate de dicționar, în ordinea în "
"care ele au fost folosite la inserarea de valori (dacă le doriți sortate, "
"atunci folosiți ``sorted(d)`` în locul instrucțiunii anterioare). Pentru a "
"determina dacă o anumită cheie a fost deja inclusă în dicționar, "
"întrebuințați cuvântul-cheie :keyword:`in`."

#: ../../tutorial/datastructures.rst:523
msgid "Here is a small example using a dictionary::"
msgstr "Iată un exemplu succint de utilizare a dicționarului::"

#: ../../tutorial/datastructures.rst:525
#, python-brace-format
msgid ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"
msgstr ""
">>> telefon_interior = {'jack': 4098, 'sape': 4139}\n"
">>> telefon_interior['guido'] = 4127\n"
">>> telefon_interior\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> telefon_interior['jack']\n"
"4098\n"
">>> del telefon_interior['sape']\n"
">>> telefon_interior['irv'] = 4127\n"
">>> telefon_interior\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(telefon_interior)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(telefon_interior)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in telefon_interior\n"
"True\n"
">>> 'jack' not in telefon_interior\n"
"False"

#: ../../tutorial/datastructures.rst:544
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences "
"of key-value pairs::"
msgstr ""
"Constructorul :func:`dict` produce dicționare de date direct din "
"secvențe de perechi cheie-valoare::"

#: ../../tutorial/datastructures.rst:547
#, python-brace-format
msgid ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:550
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"În plus, comprehensiunile de dicționare pot fi întrebuințate la a crea "
"dicționare de date din expresii arbitrare folosite de post de chei și "
"de valori::"

#: ../../tutorial/datastructures.rst:553
#, python-brace-format
msgid ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"
msgstr ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"

#: ../../tutorial/datastructures.rst:556
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs"
" using keyword arguments::"
msgstr ""
"Atunci când cheile sunt simple șiruri de caractere este mai convenabil, "
"uneori, să specificăm perechile dicționarului folosind argumente "
"cuvânt-cheie::"

#: ../../tutorial/datastructures.rst:559
#, python-brace-format
msgid ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:566
msgid "Looping Techniques"
msgstr "Tehnici de iterare"

#: ../../tutorial/datastructures.rst:568
msgid ""
"When looping through dictionaries, the key and corresponding value can be"
" retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"Atunci când iterăm de-a lungul unui dicționar, cheia și valoarea "
"corespunzătoare ei pot fi capturate simultan cu ajutorul metodei "
":meth:`~dict.items`. ::"

#: ../../tutorial/datastructures.rst:571
#, python-brace-format
msgid ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"
msgstr ""
">>> cavaleri = {'Gallahad': 'cel fără de prihană', 'Robin': 'cel viteaz'}\n"
">>> for k, v in cavaleri.items():\n"
"...     print(k, v)\n"
"...\n"
"Gallahad cel fără de prihană\n"
"Robin cel viteaz"

#: ../../tutorial/datastructures.rst:578
msgid ""
"When looping through a sequence, the position index and corresponding "
"value can be retrieved at the same time using the :func:`enumerate` "
"function. ::"
msgstr ""
"Atunci când iterăm de-a lungul unei secvențe, indicele de poziție și "
"valoarea corespunzătoare lui pot fi capturate simultan cu ajutorul "
"funcției :func:`enumerate`. ::"

#: ../../tutorial/datastructures.rst:581
msgid ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"
msgstr ""
">>> for i, v in enumerate(['x', 'și', 'zero']):\n"
"...     print(i, v)\n"
"...\n"
"0 x\n"
"1 și\n"
"2 zero"

#: ../../tutorial/datastructures.rst:588
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Pentru a itera de-a lungul a două sau mai multe secvențe în același timp, "
"elementele acestora pot fi împerecheate cu ajutorul funcției "
":func:`zip`. ::"


#: ../../tutorial/datastructures.rst:591
#, python-brace-format
msgid ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"What is your name?  It is lancelot.\n"
"What is your quest?  It is the holy grail.\n"
"What is your favorite color?  It is blue."
msgstr ""
">>> întrebări = ['numele', 'țelul', 'stindardul tău']\n"
">>> răspunsuri = ['Lancelot', 'Sfântul Potir', 'cel albastru']\n"
">>> for q, a in zip(întrebări, răspunsuri):\n"
"...     print('Care este {0} tău?  Este {1}.'.format(q, a))\n"
"...\n"
"Care este numele tău?  Este Lancelot.\n"
"Care este țelul tău?  Este Sfântul Potir.\n"
"Care este stindardul tău?  Este cel albastru."

#: ../../tutorial/datastructures.rst:600
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a "
"forward direction and then call the :func:`reversed` function. ::"
msgstr ""
"Pentru a itera de-a lungul unei secvențe în sens invers, mai întâi "
"precizați secvența în ordinea ei obișnuită după care apelați "
"funcția :func:`reversed`. ::"

#: ../../tutorial/datastructures.rst:603
msgid ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"
msgstr ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"

#: ../../tutorial/datastructures.rst:612
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Ca să iterați de-a lungul unei secvențe în ordinea sortării ei, utilizați "
"funcția :func:`sorted` care va returna o listă nouă, sortată, lăsând "
"nemodificată lista inițială. ::"

#: ../../tutorial/datastructures.rst:615
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"
msgstr ""
">>> coș = ['măr', 'portocală', 'măr', 'pară', 'portocală', 'banană']\n"
">>> for i in sorted(coș):\n"
"...     print(i)\n"
"...\n"
"banană\n"
"măr\n"
"măr\n"
"pară\n"
"portocală\n"
"portocală"

#: ../../tutorial/datastructures.rst:626
msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of"
" :func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"Aplicând :func:`set` asupra unei secvențe îi eliminăm duplicatele. "
"Întrebuințarea lui :func:`sorted` în combinație cu :func:`set` asupra "
"unei secvențe constituie o modalitate idiomatică de a itera de-a lungul "
"elementelor unicat ale secvenței în ordinea sortării acesteia. ::"

#: ../../tutorial/datastructures.rst:630
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"
msgstr ""
">>> coș = ['măr', 'portocală', 'măr', 'pară', 'portocală', 'banană']\n"
">>> for f in sorted(set(coș)):\n"
"...     print(f)\n"
"...\n"
"banană\n"
"măr\n"
"pară\n"
"portocală"

#: ../../tutorial/datastructures.rst:639
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Este tentant, uneori, să modificăm o listă în timp ce iterăm de-a lungul "
"ei; cu toate acestea, este adesea mai simplu și mai sigur să creăm o "
"listă nouă în loc să o modificăm pe cea inițială. ::"

#: ../../tutorial/datastructures.rst:642
msgid ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]"
"\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"
msgstr ""
">>> import math\n"
">>> date_brute = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]"
"\n"
">>> date_filtrate = []\n"
">>> for valoarea in date_brute:\n"
"...     if not math.isnan(valoarea):\n"
"...         date_filtrate.append(valoarea)\n"
"...\n"
">>> date_filtrate\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"

#: ../../tutorial/datastructures.rst:656
msgid "More on Conditions"
msgstr "Mai multe despre expresiile de control"

#: ../../tutorial/datastructures.rst:658
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"*Condițiile* de îndeplinit (sau *expresiile condiționale* ori *expresiile "
"de control*) conținute în instrucțiunile ``while`` și ``if`` pot folosi "
"orice fel de operatori nu doar pe cei de comparație (relaționali)."

#: ../../tutorial/datastructures.rst:662
msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"Operatorii de comparație ``in`` și ``not in`` realizează teste de "
"apartenență care determină dacă o valoare se află (sau nu se află) "
"într-un container. Operatorii ``is`` și ``is not`` compară două obiecte "
"pentru a stabili dacă ele sunt, cu adevărat, același obiect. Toți "
"operatorii de comparație au aceeași prioritate, aceasta fiind mai mică "
"decât cea a indiferent cărui operator numeric."

#: ../../tutorial/datastructures.rst:668
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether "
"``a`` is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Operațiile de comparație pot fi înlănțuite. De exemplu, ``a < b == c`` "
"va testa dacă ``a`` este (strict) mai mic decât ``b`` și dacă ``b`` este "
"egal cu ``c``."

#: ../../tutorial/datastructures.rst:671
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and "
"``or``, and the outcome of a comparison (or of any other Boolean "
"expression) may be negated with ``not``.  These have lower priorities "
"than comparison operators; between them, ``not`` has the highest priority"
" and ``or`` the lowest, so that ``A and not B or C`` is equivalent to "
"``(A and (not B)) or C``. As always, parentheses can be used to express "
"the desired composition."
msgstr ""
"Expresiile condiționale pot fi combinate folosind operatorii booleeni "
"``and`` și ``or``, iar rezultatul unei comparații (ori valoarea de "
"adevăr a oricărei alte expresii booleene) poate fi negat cu ``not``. "
"Acești operatori booleeni au priorități mai mici decât cele ale "
"operatorilor de comparație; dintre ei, ``not`` are prioritatea cea mai "
"mare iar ``or`` pe cea mai mică, astfel că expresia ``A and not B or C`` "
"este echivalentă cu ``(A and (not B)) or C``. Ca de obicei, parantezele "
"rotunde pot fi întrebuințate la construcția compoziției dorite a oricărei "
"expresii."

#: ../../tutorial/datastructures.rst:678
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and "
"evaluation stops as soon as the outcome is determined.  For example, if "
"``A`` and ``C`` are true but ``B`` is false, ``A and B and C`` does not "
"evaluate the expression ``C``.  When used as a general value and not as a"
" Boolean, the return value of a short-circuit operator is the last "
"evaluated argument."
msgstr ""
"Operatorii booleeni ``and`` și ``or`` fac parte din așa-numiții *operatori "
"de scurtcircuit*: argumentele (operanzii) lor se evaluează de la stânga "
"către dreapta iar evaluarea se oprește de îndată ce rezultatul este "
"determinat. De exemplu, dacă expresiile ``A`` și ``C`` sunt adevărate iar "
"``B`` este falsă, atunci evaluarea expresiei ``A and B and C`` nu "
"necesită evaluarea lui ``C``. Dacă este folosită ca valoare generală "
"și nu ca dată booleană (valoare de adevăr), valoarea returnată de un "
"operator de scurtcircuit este ultimul argument evaluat."

#: ../../tutorial/datastructures.rst:685
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"Este posibil să atribuim rezultatul unei operații de comparare ori pe "
"cel al evaluării altei expresii booleene unei variabile. De exemplu, ::"

#: ../../tutorial/datastructures.rst:688
msgid ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"
msgstr ""
">>> șirul1, șirul2, șirul3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> nenul = șirul1 or șirul2 or șirul3\n"
">>> nenul\n"
"'Trondheim'"

#: ../../tutorial/datastructures.rst:693
msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done"
" explicitly with the :ref:`walrus operator <why-can-t-i-use-an-"
"assignment-in-an-expression>` ``:=``. This avoids a common class of "
"problems encountered in C programs: typing ``=`` in an expression when "
"``==`` was intended."
msgstr ""
"Atenție la faptul că în Python, spre deosebire de C, atribuirile din "
"interiorul expresiilor trebuie realizate folosind în mod explicit "
":ref:`operatorul morsă <why-can-t-i-use-an-assignment-in-an-expression>` "
"``:=``. Această restricție ne permite să evităm un tip de dificultăți "
"întâlnite în mod obișnuit la programarea în C: situația în care tastăm "
"``=`` într-o expresie în care intenționam să introducem ``==``."

#: ../../tutorial/datastructures.rst:703
msgid "Comparing Sequences and Other Types"
msgstr "Comparând secvențe și alte tipuri de obiecte"

#: ../../tutorial/datastructures.rst:704
msgid ""
"Sequence objects typically may be compared to other objects with the same"
" sequence type. The comparison uses *lexicographical* ordering: first the"
" first two items are compared, and if they differ this determines the "
"outcome of the comparison; if they are equal, the next two items are "
"compared, and so on, until either sequence is exhausted. If two items to "
"be compared are themselves sequences of the same type, the "
"lexicographical comparison is carried out recursively.  If all items of "
"two sequences compare equal, the sequences are considered equal. If one "
"sequence is an initial sub-sequence of the other, the shorter sequence is"
" the smaller (lesser) one.  Lexicographical ordering for strings uses the"
" Unicode code point number to order individual characters. Some examples "
"of comparisons between sequences of the same type::"
msgstr ""
"Obiectele secvență se compară, de obicei, cu alte obiecte de același tip "
"secvență. Operația de comparare folosește ordinea *lexicografică*: mai "
"întâi sunt comparate primul element al unuia din cele două obiecte cu "
"primul element al celuilalt obiect, iar dacă acestea diferă unul de "
"celălalt, atunci diferența dintre ele determină rezultatul comparației; în "
"schimb, dacă cele două elemente sunt egale, atunci se va compara cel de-al "
"doilea element al primului obiect cu cel de-al doilea element al celuilalt "
"obiect și așa mai departe, până când vom ajunge la finalul  (măcar) unuia "
"dintre obiecte. Dacă se întâmplă ca elementele care sunt comparate să fie "
"ele însele obiecte ale aceluiași tip secvență, atunci comparația "
"lexicografică va fi continuată în mod recursiv. Dacă toate elementele "
"celor două obiecte secvență sunt egale două câte două, atunci obiectele "
"secvență vor fi considerate egale. Dacă unul dintre obiecte este, de la "
"început, o sub-secvență a celuilalt obiect, atunci obiectul mai scurt este "
"cel mai mic (dintre cele două). Ordinea lexicografică a șirurilor de "
"caractere întrebuințează numerele de punct de cod Unicode pentru ordonarea "
"caracterelor individuale. Iată câteva exemple de comparații între secvențe "
"de același tip::"

#: ../../tutorial/datastructures.rst:716
msgid ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
msgstr ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"

#: ../../tutorial/datastructures.rst:724
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is "
"legal provided that the objects have appropriate comparison methods.  For"
" example, mixed numeric types are compared according to their numeric "
"value, so 0 equals 0.0, etc.  Otherwise, rather than providing an "
"arbitrary ordering, the interpreter will raise a :exc:`TypeError` "
"exception."
msgstr ""
"Remarcați că este permisă operația de comparare a obiectelor de tipuri "
"diferite folosind operatorii ``<`` sau ``>`` cu condiția ca obiectele "
"corespunzătoare să posede metode de comparație potrivite. De exemplu, "
"tipurile numerice diferite se compară folosind valoarea numerică a "
"obiectelor lor, astfel că 0 este egal cu 0.0 șamd. În caz contrar, în "
"loc să furnizeze o ordonare arbitrară, interpretorul va ridica o "
"excepție :exc:`TypeError`."

#: ../../tutorial/datastructures.rst:732
msgid "Footnotes"
msgstr "Note de subsol"

#: ../../tutorial/datastructures.rst:733
msgid ""
"Other languages may return the mutated object, which allows method "
"chaining, such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"În alte limbaje de programare, este posibil să se returneze obiectul "
"mutat, ceea ce va permite înlănțuirea metodelor, cum ar fi "
"``d->insert(\"a\")->remove(\"b\")->sort();``."

