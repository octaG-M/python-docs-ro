# CLASE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Octavian Mustafa <octawian@yahoo.com>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-17 17:56+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ro\n"
"Language-Team: ro <octawian@yahoo.com>\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : (n==0 || (n%100 > 0 && n%100"
" < 20)) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "Clase"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can"
" also have methods (defined by its class) for modifying its state."
msgstr ""
"Clasele constituie o modalitate de a aduce laolaltă date și "
"funcționalități. Atunci când creăm o clasă nouă, creăm un nou *tip* de "
"obiecte, adică stabilim felul în care pot fi construite *instanțe* ale "
"tipului respectiv. Fiecărei instanțe a unei clase oarecare îi putem atașa "
"atribute în scopul păstrării stării instanței în cauză. Instanțele clasei "
"pot dispune și de metode (definite în cadrul acelei clase), folosite la "
"modificarea stărilor lor."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of "
"the class mechanisms found in C++ and Modula-3.  Python classes provide "
"all the standard features of Object Oriented Programming: the class "
"inheritance mechanism allows multiple base classes, a derived class can "
"override any methods of its base class or classes, and a method can call "
"the method of a base class with the same name.  Objects can contain "
"arbitrary amounts and kinds of data.  As is true for modules, classes "
"partake of the dynamic nature of Python: they are created at runtime, and"
" can be modified further after creation."
msgstr ""
"În comparație cu alte limbaje de programare, mecanismul claselor din Python "
"adaugă clase (la familia de tipuri de date deja existente) cu un minim de "
"sintaxă, respectiv de "
"`semantică <https://en.wikipedia.org/wiki/Semantics_(computer_science)>`_ "
"(în sensul dat în teoria compilatoarelor). El este o mixtură a mecanismelor "
"privitoare la clase pe care le găsim în C++ și în Modula-3. Clasele (din) "
"Python posedă toate trăsăturile tipice pe care le cere *Programarea "
"orientată-obiect* (adică, POO; se folosesc și constructele *Programare "
"orientată pe obiecte*, respectiv *Programare orientată înspre obiecte*): "
"mecanismul de moștenire a claselor îngăduie mai multe clase de bază "
"(numite și *superclase* ori *clase-părinte*), orice clasă derivată își "
"poate suprascrie (de la englezescul, în jargon, *override*) metodele "
"moștenite de la una sau de la mai multe din clasele de bază, iar orice "
"metodă (a unei anumite clase) poate apela metoda omonimă a uneia din "
"clasele de bază (ale clasei respective). Obiectele pot conține cantități "
"și tipuri oarecare de date. Aidoma modulelor, clasele împărtășesc natura "
"dinamică a Python-ului: ele sunt create în timpul execuției (sau, în jargon "
"informatic, la *runtime*) și pot fi modificate după ce au fost create."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) "
"are *public* (except see below :ref:`tut-private`), and all member "
"functions are *virtual*.  As in Modula-3, there are no shorthands for "
"referencing the object's members from its methods: the method function is"
" declared with an explicit first argument representing the object, which "
"is provided implicitly by the call.  As in Smalltalk, classes themselves "
"are objects.  This provides semantics for importing and renaming.  Unlike"
" C++ and Modula-3, built-in types can be used as base classes for "
"extension by the user.  Also, like in C++, most built-in operators with "
"special syntax (arithmetic operators, subscripting etc.) can be redefined"
" for class instances."
msgstr ""
"Urmând terminologia C++, membrii obișnuiți ai unei clase (incluzând aici "
"*datele-membru*; sunt utilizate și constructele *datele membre*, respectiv "
"*variabilele de instanță*) sunt *publici* (cu excepția, vezi mai jos, "
":ref:`tut-private`), pe când toate funcțiile-membru (ori *funcțiile "
"membre*) sunt *virtuale*. La fel ca în Modula-3, nu există simplificări "
"de notație care să deosebească membrii unui obiect de metodele obiectului: "
"funcția metodă se declară cu primul argument (dat) explicit ca "
"reprezentând obiectul, acesta urmând a fi transmis, în mod implicit, la "
"apelul funcției. Precum în Smalltalk, clasele însele sunt obiecte. O atare "
"particularitate aduce cu sine o semantică a importării și a redenumirii. "
"Spre deosebire de C++ ori de Modula-3, tipurile predefinite (de date) pot "
"fi întrebuințate drept clase de bază la extinderile realizate de "
"către utilizator. De asemeni, ca în C++, majoritatea operatorilor "
"predefiniți care au o sintaxă specială (cum ar fi operatorii aritmetici, "
"operatorul de indexare șamd.) pot fi redefiniți pentru instanțele unor "
"clase oarecare."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will "
"make occasional use of Smalltalk and C++ terms.  I would use Modula-3 "
"terms, since its object-oriented semantics are closer to those of Python "
"than C++, but I expect that few readers have heard of it.)"
msgstr ""
"(Dată fiind lipsa unei terminologii unanim acceptate în discuțiile relative "
"la clase, vom folosi ocazional formulări specifice C++-ului și Smalltalk-"
"ului. Am fi întrebuințat termeni din Modula-3, căci semantica orientată-"
"obiect a acestuia este mai apropiată de Python decât cea a C++-ului, dacă "
"nu am bănui că prea puțini dintre cititori au auzit de acest limbaj.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "O vorbă despre nume și obiecte"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can "
"be bound to the same object.  This is known as aliasing in other "
"languages.  This is usually not appreciated on a first glance at Python, "
"and can be safely ignored when dealing with immutable basic types "
"(numbers, strings, tuples).  However, aliasing has a possibly surprising "
"effect on the semantics of Python code involving mutable objects such as "
"lists, dictionaries, and most other types. This is usually used to the "
"benefit of the program, since aliases behave like pointers in some "
"respects.  For example, passing an object is cheap since only a pointer "
"is passed by the implementation; and if a function modifies an object "
"passed as an argument, the caller will see the change --- this eliminates"
" the need for two different argument passing mechanisms as in Pascal."
msgstr ""
"Obiectele au individualitate și este permis ca nume diferite (din *domenii "
"de valabilitate* distincte; de la englezescul *scope*; se folosește și "
"constructul *domenii de vizibilitate*) să fie legate de același obiect. În "
"alte limbaje de programare, o atare permisiune este cunoscută drept "
"*întrebuințare de pseudonime* (de la englezescul *aliasing*; sau *atribuire "
"de pseudonime*). Pseudonimele se folosesc rar de către cei aflați la primul "
"contact cu Python-ul, utilizarea lor putând fi evitată în mod eficient "
"atunci când avem de a face, în programul nostru, cu tipurile de date "
"elementare care sunt imutabile (numere, șiruri de caractere, tupluri). Pe "
"de altă parte, atribuirea de pseudonime poate avea efecte neașteptate "
"asupra semanticii programelor Python care întrebuințează obiecte mutabile "
"precum listele, dicționarele de date șamd. Pseudonimele îi sunt utile unui "
"program Python deoarece se comportă ca niște *pointeri* în anumite "
"privințe. De exemplu, transmiterea (ca argument al unei funcții oarecare) "
"unui obiect este ieftină căci implementarea se îngrijește să fie transmis "
"doar un pointer; iar dacă funcția va modifica obiectul transmis ei ca "
"argument, atunci apelantul va observa schimbarea intervenită --- ceea ce "
"elimină nevoia de a dispune de două mecanisme de transmitere a "
"argumentelor, ca în Pascal."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Domenii de valabilitate și spații de nume în Python"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is"
" useful for any advanced Python programmer."
msgstr ""
"Înainte de a introduce clasele, trebuie să discutăm puțin despre regulile "
"Python-ului în ceea ce privește domeniile de valabilitate. Definițiile "
"claselor le joacă adesea feste celor care utilizează spațiile de nume (de "
"la englezescul *namespace*), așa că este important să cunoașteți precis cum "
"funcționează domeniile de valabilitate și spațiile de nume pentru a putea "
"urmări îndeaproape cum evoluează lucrurile. Că tot a venit vorba, "
"cunoașterea acestei problematici îi este utilă oricărui programator matur "
"în Python."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Să începem cu câteva definiții."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names "
"(containing functions such as :func:`abs`, and built-in exception names);"
" the global names in a module; and the local names in a function "
"invocation.  In a sense the set of attributes of an object also form a "
"namespace.  The important thing to know about namespaces is that there is"
" absolutely no relation between names in different namespaces; for "
"instance, two different modules may both define a function ``maximize`` "
"without confusion --- users of the modules must prefix it with the module"
" name."
msgstr ""
"Un *spațiu de nume* este o *asociere* (sau o *corespondență*; de la "
"englezescul *mapping*; se folosește, ca jargon informatic, și termenul de "
"*mapare*) a unor nume cu niște obiecte. Cele mai multe spații de nume sunt "
"implementate în Python, la momentul de față, ca dicționare de date, însă "
"respectiva implementare nu iese în evidență prin nimic (poate cu excepția "
"performanței) și există posibilitatea ca ea să se schimbe în viitor. "
"Exemple de spații de nume sunt următoarele: setul numelor predefinite "
"(conținând funcții precum :func:`abs`, respectiv nume de excepții "
"predefinite); numele globale dintr-un modul; ori numele locale dintr-un "
"apel de funcție. Lucrul important de reținut despre spațiile de nume este "
"că nu există niciun fel de legătură între numele situate în spații de nume "
"diferite; de exemplu, două module distincte pot defini fără pericol de "
"confuzie (câte) o funcție intitulată ``maximizează`` -- ca să folosească o "
"astfel de funcție, utilizatorii modulelor vor avea de prefixat numele ei cu "
"numele modulului care o conține."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- "
"for example, in the expression ``z.real``, ``real`` is an attribute of "
"the object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname``"
" is a module object and ``funcname`` is an attribute of it.  In this case"
" there happens to be a straightforward mapping between the module's "
"attributes and the global names defined in the module: they share the "
"same namespace!  [#]_"
msgstr ""
"Apropo, folosim cuvântul *atribut* pentru a ne referi la orice nume care îi "
"urmează unui (`operator <https://isocpp.org/blog/2016/02/a-bit-of-"
"background-for-the-operator-dot-proposal-bjarne-stroustrup>`_) "
"punct --- cum ar fi faptul că, în expresia ``z.real``, ``real`` "
"(`partea reală <https://en.wikipedia.org/wiki/Complex_number>`_) "
"este un atribut al obiectului ``z``. Într-o exprimare riguroasă, referirea "
"la numele dintr-un modul este o referire la niște atribute: în expresia "
"``nume_de_modul.nume_de_funcție``, ``nume_de_modul`` desemnează numele unui "
"modul pe când ``nume_de_funcție`` pe cel al unui atribut al acestui modul. "
"În cazul de față se întâmplă să existe o mapare ușor de sesizat între "
"atributele modulului și numele globale definite în modul: ele împart "
"același spațiu de nume! [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment "
"to attributes is possible.  Module attributes are writable: you can write"
" ``modname.the_answer = 42``.  Writable attributes may also be deleted "
"with the :keyword:`del` statement.  For example, ``del "
"modname.the_answer`` will remove the attribute :attr:`!the_answer` from "
"the object named by ``modname``."
msgstr ""
"Atributele pot fi sau *doar-de-citit* sau *editabile* (de la englezescul "
"*writable*). În cel de-al doilea caz, atributelor li se pot asigna valori. "
"Atributele unui modul sunt editabile: putem scrie ``nume_de_modul.răspunsul "
"= 42``. De asemeni, atributele editabile pot fi șterse, cu ajutorul "
"instrucțiunii :keyword:`del`. De exemplu, ``del nume_de_modul.răspunsul`` "
"va elimina atributul :attr:`!răspunsul` din obiectul numit "
"``nume_de_modul``."


#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes."
"  The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module"
" namespaces also last until the interpreter quits.  The statements "
"executed by the top-level invocation of the interpreter, either read from"
" a script file or interactively, are considered part of a module called "
":mod:`__main__`, so they have their own global namespace.  (The built-in "
"names actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Spațiile de nume sunt create la momente de timp diferite și au durate de "
"viață variate. Spațiul de nume care conține numele predefinite este creat "
"la pornirea interpretorului de Python, fără a mai fi șters pe întreaga "
"durată a funcționării acestuia. Spațiul de nume global al unui modul este "
"creat odată cu citirea de către interpretor a definiției modulului în "
"cauză; în mod obișnuit, spațiile de nume ale modulelor rămân în viață până "
"la oprirea interpretorului. Instrucțiunile executate de o invocare de la "
"cel mai înalt nivel a interpretorului, fie că au fost citite dintr-un "
"fișier de script fie că au fost introduse în mod interactiv, sunt "
"considerate că făcând parte dintr-un modul numit :mod:`__main__`, astfel "
"că ele posedă propriul lor spațiu de nume global. (Numele predefinite, la "
"rândul lor, funcționează într-un modul; acesta se numește :mod:`builtins`.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is "
"called, and deleted when the function returns or raises an exception that"
" is not handled within the function.  (Actually, forgetting would be a "
"better way to describe what actually happens.)  Of course, recursive "
"invocations each have their own local namespace."
msgstr ""
"Spațiul de nume local al unei funcții este creat la apelul funcției și este "
"șters fie la returnarea din execuția codului funcției fie atunci când, în "
"codul funcției, este ridicată o excepție care nu va fi interceptată în "
"cadrul funcției respective. (De fapt, *uitare* ar fi termenul potrivit "
"pentru a descrie ceea ce se întâmplă cu adevărat într-o atare situație.) "
"Evident, invocările recursive ale unei funcții au fiecare propriul său "
"spațiu de nume."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an "
"unqualified reference to a name attempts to find the name in the "
"namespace."
msgstr ""
"Un *domeniu de valabilitate* este o zonă de text dintr-un program Python "
"în care un anumit spațiu de nume este accesibil în mod direct. Prin "
"\"accesibil în mod direct\" înțelegem faptul că referințele *necalificate* "
"la nume oarecare reușesc să identifice despre ce nume este vorba în acel "
"spațiu de nume."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At "
"any time during execution, there are 3 or 4 nested scopes whose "
"namespaces are directly accessible:"
msgstr ""
"Cu toate că domeniile de valabilitate sunt stabilite *static*, utilizarea "
"lor se face *dinamic*. La orice moment de timp de pe parcursul execuției "
"unui program Python, există 3 sau 4 domenii de valabilitate imbricate la "
"ale căror spații de nume avem acces în mod direct:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"domeniul de valabilitate poziționat cel mai adânc în interiorul "
"codului, acela din care va începe orice căutare de nume, el conține "
"numele locale"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with "
"the nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"domeniile de valabilitate ale funcțiilor care înglobează codul (de la "
"englezescul *enclosing*), în care căutările de nume se realizează pornind "
"de la domeniul de includere (al codului) situat cel mai adânc, acestea "
"deținând atât nume ne-locale cât și nume ne-globale"

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "penultimul (dinspre interiorul către exteriorul codului) domeniu "
"de valabilitate conține numele globale ale modulului curent"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"domeniul de valabilitate cel mai de sus (ultimul în care se va căuta "
"numele respectiv) este spațiul de nume care cuprinde numele predefinite"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names."
"  To rebind variables found outside of the innermost scope, the "
":keyword:`nonlocal` statement can be used; if not declared nonlocal, "
"those variables are read-only (an attempt to write to such a variable "
"will simply create a *new* local variable in the innermost scope, leaving"
" the identically named outer variable unchanged)."
msgstr ""
"Atunci când un nume este declarat ca fiind *global*, toate referirile la "
"el precum și toate atribuirile către el vor fi realizate în domeniul de "
"valabilitate penultim, adică în domeniul care deține toate numele globale "
"ale modulului. Pentru a lega din nou variabilele găsite în exteriorul "
"celui mai adânc situat dintre domeniile de valabilitate poate fi "
"întrebuințată instrucțiunea :keyword:`nonlocal` (adică, o declarație de "
"ne-local); dacă nu au fost declarate drept ne-locale, atunci asemenea "
"variabile sunt doar-de-citit (orice tentativă de a edita o atare "
"variabilă va conduce la crearea unei variabile locale *noi*, conținută în "
"domeniul de valabilitate poziționat cel mai adânc, în timp ce numele "
"omonim din exterior nu-și va modifica valoarea)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same"
" namespace as the global scope: the module's namespace. Class definitions"
" place yet another namespace in the local scope."
msgstr ""
"Domeniul de valabilitate local se referă, în mod obișnuit, la numele locale "
"ale (chiar) funcției de față. În exteriorul codului de funcții, domeniul "
"de valabilitate local face referire la același spațiu de nume ca și "
"domeniul de valabilitate global: adică la spațiul de nume al modulului. "
"Definițiile claselor, la rândul lor, plasează alte spații de nume în "
"domeniul de valabilitate local."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the "
"global scope of a function defined in a module is that module's "
"namespace, no matter from where or by what alias the function is called."
"  On the other hand, the actual search for names is done dynamically, at "
"run time --- however, the language definition is evolving towards static "
"name resolution, at \"compile\" time, so don't rely on dynamic name "
"resolution!  (In fact, local variables are already determined "
"statically.)"
msgstr ""
"Este important să realizăm că domeniile de valabilitate se determină "
"textual: domeniul de valabilitate global al unei funcții definite într-"
"un modul este chiar spațiul de nume al modulului respectiv, indiferent "
"de unde ori sub ce pseudonim s-a realizat apelul funcției în cauză. Pe "
"de altă parte, căutarea efectivă a unui anumit nume se realizează "
"dinamic, pe parcursul execuției programului --- cu toate acestea, "
"definiția Python-ului ca limbaj de programare evoluează către o "
"rezolvare statică a numelor, adică una la momentul \"compilării\", "
"motiv pentru care vă recomandăm să nu vă bazați pe rezolvări dinamice "
"de nume! (În fapt, variabilele locale sunt deja determinate static.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or "
":keyword:`nonlocal` statement is in effect -- assignments to names always"
" go into the innermost scope. Assignments do not copy data --- they just "
"bind names to objects.  The same is true for deletions: the statement "
"``del x`` removes the binding of ``x`` from the namespace referenced by "
"the local scope.  In fact, all operations that introduce new names use "
"the local scope: in particular, :keyword:`import` statements and function"
" definitions bind the module or function name in the local scope."
msgstr ""
"O caracteristică aparte a Python-ului -- atunci când nu ne găsim sub "
"efectul vreuneia din instrucțiunile :keyword:`global` ori "
":keyword:`nonlocal` -- este aceea că atribuirile către nume se fac "
"întotdeauna în domeniul de valabilitate poziționat cel mai adânc în "
"interiorul codului. Atribuirile nu copiază date --- ele doar leagă "
"nume de obiecte. Același lucru este valabil și pentru ștergeri: "
"instrucțiunea ``del x`` elimină legătura lui ``x`` din spațiul de "
"nume la care se referă domeniul de valabilitate local. În fapt, orice "
"operație care introduce nume noi întrebuințează domeniul de valabilitate "
"local: în particular, instrucțiunile :keyword:`import` precum și "
"definițiile de funcții leagă fie numele modulului fie numele funcției "
"de domeniul de valabilitate local."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the "
":keyword:`nonlocal` statement indicates that particular variables live in"
" an enclosing scope and should be rebound there."
msgstr ""
"Instrucțiunea :keyword:`global` poate fi utilizată la a arăta că o anume "
"variabilă trăiește în domeniul de valabilitate global, astfel că trebuie "
"re-legată (tot) în el; instrucțiunea :keyword:`nonlocal` indică faptul că "
"variabila respectivă trăiește într-un domeniu de valabilitate care "
"înglobează codul de față, deci că va trebui re-legată în acela."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Un exemplu cu domenii de valabilitate și spații de nume"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes "
"and namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Acesta este un exemplu care ilustrează cum trebuie referențiate diversele "
"domenii de valabilitate și spațiile de nume, respectiv cum afectează "
"cuvintele-cheie :keyword:`global` și :keyword:`nonlocal` legarea unei "
"variabile oarecare::"

#: ../../tutorial/classes.rst:168
msgid ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"
msgstr ""
"def testează_domeniul_de_vizibilitate():\n"
"    def construiește_ceva_local():\n"
"        șuncă = \"șuncă produsă local\"\n"
"\n"
"    def construiește_ceva_nelocal():\n"
"        nonlocal șuncă\n"
"        șuncă = \"șuncă produsă ne-local\"\n"
"\n"
"    def construiește_ceva_global():\n"
"        global șuncă\n"
"        șuncă = \"șuncă produsă global\"\n"
"\n"
"    șuncă = \"testez șunca\"\n"
"    construiește_ceva_local()\n"
"    print(\"După asignarea locală:\", șuncă)\n"
"    construiește_ceva_nelocal()\n"
"    print(\"După asignarea ne-locală:\", șuncă)\n"
"    construiește_ceva_global()\n"
"    print(\"După asignarea globală:\", șuncă)\n"
"\n"
"testează_domeniul_de_vizibilitate()\n"
"print(\"În domeniul de valabilitate global:\", șuncă)"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "Rezultatul rulării codului din exemplu este următorul:"

#: ../../tutorial/classes.rst:193
msgid ""
"After local assignment: test spam\n"
"After nonlocal assignment: nonlocal spam\n"
"After global assignment: nonlocal spam\n"
"In global scope: global spam"
msgstr ""
"După asignarea locală: testez șunca\n"
"După asignarea ne-locală: șuncă produsă ne-local\n"
"După asignarea globală: șuncă produsă ne-local\n"
"În domeniul de valabilitate global: șuncă produsă global"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Remarcați că atribuirea *local* (deci, cea standard) nu a modificat "
"legarea lui *șuncă* dată de *testează_domeniul_de_vizibilitate*. În "
"schimb, atribuirea :keyword:`nonlocal` a schimbat legarea lui *șuncă* dată "
"de *testează_domeniul_de_vizibilitate*, respectiv atribuirea "
":keyword:`global` a modificat legarea la nivel de modul."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the"
" :keyword:`global` assignment."
msgstr ""
"În plus, puteți observa că *șuncă* nu a fost legat în niciun fel până la "
"momentul asignării :keyword:`global`."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Prima privire aruncată asupra claselor"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and"
" some new semantics."
msgstr ""
"Clasele aduc un strop de nou în conținutul sintaxei, alte trei tipuri de "
"obiecte, precum și ceva noutăți la semantică."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Sintaxa definiției unei clase"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "Cea mai simplă formă a definiției unei clase arată astfel::"

#: ../../tutorial/classes.rst:225
msgid ""
"class ClassName:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class NumeleClasei:\n"
"    <instrucțiunea-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <instrucțiunea-N>"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably "
"place a class definition in a branch of an :keyword:`if` statement, or "
"inside a function.)"
msgstr ""
"Definițiile de clase, aidoma definițiilor de funcții (instrucțiuni "
":keyword:`def`) trebuie executate mai întâi pentru a avea efect. (Dat "
"fiind că nu este exclus să plasați o definiție de clasă într-una din "
"ramificațiile unei instrucțiuni :keyword:`if`, după cum nu este imposibil "
"nici să o inserați în codul vreunei funcții.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes "
"useful --- we'll come back to this later.  The function definitions "
"inside a class normally have a peculiar form of argument list, dictated "
"by the calling conventions for methods --- again, this is explained "
"later."
msgstr ""
"În practică, instrucțiunile din codul definiției unei clase vor fi mai "
"ales definiții de funcții, cu toate că sunt permise și altfel de "
"instrucțiuni, și încă cu mult folos --- vom reveni la aceasta mai "
"târziu. Definițiile de funcții din interiorul (codului) unei clase "
"impun (de obicei) o formă neobișnuită a listei de argumente, formă "
"dictată de convențiile de apel ale metodelor --- și aceste aspecte vor "
"fi explicate ulterior."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used "
"as the local scope --- thus, all assignments to local variables go into "
"this new namespace.  In particular, function definitions bind the name of"
" the new function here."
msgstr ""
"Atunci când interpretorul citește definiția unei clase, un spațiu de nume "
"(nou) va fi creat și întrebuințat ca domeniu de valabilitate local --- "
"astfel, toate atribuirile către variabile locale vor fi realizate în cadrul "
"acestui (nou) spațiu de nume. În particular, definițiile de funcții leagă "
"fiecare nume nou de funcție de acest domeniu de valabilitate."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* "
"is created.  This is basically a wrapper around the contents of the "
"namespace created by the class definition; we'll learn more about class "
"objects in the next section.  The original local scope (the one in effect"
" just before the class definition was entered) is reinstated, and the "
"class object is bound here to the class name given in the class "
"definition header (:class:`!ClassName` in the example)."
msgstr ""
"Atunci când interpretorul părăsește în mod normal codul unei definiții de "
"clasă (deci, după ce a ajuns la finalul acestui cod), va fi creat un "
"*obiect clasă*. Acesta este, în fapt, o *împachetare* (sau o *învelitoare*; "
"de la englezescul *wrapper*) a conținutului acelui spațiu de nume creat de "
"însăși definiția clasei; vom afla mai multe despre obiectele clasă în "
"secțiunea următoare. Domeniul de valabilitate local în care ne aflam "
"(adică, domeniul vizibil înainte ca interpretorul să ajungă la definiția "
"clasei) este reinstaurat iar obiectul clasă este legat de numele clasei dat "
"în antetul definiției acesteia (:class:`!NumeleClasei` din exemplul nostru)."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Obiectele clasă"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Obiectele clasă permit două feluri de operații: referirea la atribute și "
"instanțierea."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the "
"names that were in the class's namespace when the class object was "
"created.  So, if the class definition looked like this::"
msgstr ""
"*Referirea la atribute* (de clasă; sau *referențierea atributelor* ori "
"*referința la atribute*) întrebuințează sintaxa tipică din Python a "
"referirii la atribute oarecare: ``obiect.nume``. Numele valide de atribute "
"alcătuiesc întreg ansamblul de nume din spațiul de nume al clasei la "
"momentul creării obiectului clasă. Astfel, dacă definiția clasei arată ca "
"mai jos::"

#: ../../tutorial/classes.rst:269
msgid ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"
msgstr ""
"class ClasaMea:\n"
"    \"\"\"Un exemplu simplist de clasă\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'salutare, lume'"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class "
"attributes can also be assigned to, so you can change the value of "
"``MyClass.i`` by assignment. :attr:`~type.__doc__` is also a valid "
"attribute, returning the docstring belonging to the class: ``\"A simple "
"example class\"``."
msgstr ""
"atunci ``ClasaMea.i`` și ``ClasaMea.f`` sunt referiri valide la atribute, "
"care returnează un număr întreg, respectiv un obiect funcție. Atributelor "
"de clasă le putem realiza asignări, așa că valoarea lui ``ClasaMea.i`` "
"poate fi modificată prin atribuire. Și :attr:`~type.__doc__` este un "
"atribut valid, returnând docstring-ul clasei: ``\"Un exemplu simplist "
"de clasă\"``."

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the "
"class object is a parameterless function that returns a new instance of "
"the class. For example (assuming the above class)::"
msgstr ""
"*Instanțierea* unei clase utilizează notația cu `operatorul funcție "
"<https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B>`_. Ne putem "
"închipui că obiectul clasă este o funcție fără parametri care întoarce "
"o (nouă) instanță a clasei. De exemplu (folosind clasa de mai sus)::"

#: ../../tutorial/classes.rst:286 ../../tutorial/classes.rst:303
msgid "x = MyClass()"
msgstr "x = ClasaMea()"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the "
"local variable ``x``."
msgstr ""
"creează o *instanță* nouă a clasei și îi atribuie obiectul nou creat "
"variabilei locale ``x``."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty"
" object. Many classes like to create objects with instances customized to"
" a specific initial state. Therefore a class may define a special method "
"named :meth:`~object.__init__`, like this::"
msgstr ""
"Operația de *instanțiere* (adică de \"apelare\" a unui obiect clasă; de la "
"englezescul *instantiation*) creează un obiect *gol* (vid). Pentru multe "
"clase utilizate în practică se dorește crearea de instanțe particularizate "
"printr-o *stare inițială* specificată (de către utilizator). Din acest "
"motiv, unei clase îi poate fi definită o metodă specială, numită "
":meth:`~object.__init__`, după cum urmează::"

#: ../../tutorial/classes.rst:296
msgid ""
"def __init__(self):\n"
"    self.data = []"
msgstr ""
"def __init__(self):\n"
"    self.datele_clasei = []"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class "
"instantiation automatically invokes :meth:`!__init__` for the newly "
"created class instance.  So in this example, a new, initialized instance "
"can be obtained by::"
msgstr ""
"Atunci când în codul unei clase este definită (și) metoda "
":meth:`~object.__init__`, instanțierea clasei respective va invoca în mod "
"automat această metodă pentru nou creata instanță a clasei. Așadar, în "
"exemplul nostru, o instanță nouă, *inițializată*, poate fi obținută prin::"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, "
"::"
msgstr ""
"Firește, metoda :meth:`~object.__init__` poate primi argumente, această "
"caracteristică sporindu-i flexibilitatea în utilizare. Într-o atare "
"situație, argumentele date operatorului de instanțiere a clasei îi vor fi "
"transmise lui :meth:`!__init__`. Astfel,"

#: ../../tutorial/classes.rst:309
msgid ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"
msgstr ""
">>> class NumărComplex:\n"
"...     def __init__(self, partea_reală, partea_imaginară):\n"
"...         self.real = partea_reală\n"
"...         self.imaginar = partea_imaginară\n"
"...\n"
">>> x = NumărComplex(3.0, -4.5)\n"
">>> x.real, x.imaginar\n"
"(3.0, -4.5)"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Obiectele instanță"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood"
" by instance objects are attribute references.  There are two kinds of "
"valid attribute names: data attributes and methods."
msgstr ""
"Odată ajunși aici, la ce putem întrebuința aceste obiecte instanță? "
"Singurele operații înțelese de obiectele instanță sunt referențierile de "
"atribute. Există două tipuri de nume de atribute valide: atributele datelor "
"(sau *atributele de date*) și metodele (adică, *atributele de funcții*)."

#: ../../tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and "
"to \"data members\" in C++.  Data attributes need not be declared; like "
"local variables, they spring into existence when they are first assigned "
"to.  For example, if ``x`` is the instance of :class:`!MyClass` created "
"above, the following piece of code will print the value ``16``, without "
"leaving a trace::"
msgstr ""
"*atributele de date* le corespund \"variabilelor de instanță\" din "
"Smalltalk, respectiv \"membrilor date\" din C++. Atributele (de) date "
"nu au nevoie să fie *declarate*; asemenea variabilelor locale, ele "
"*prind viață* (sunt *vivificate*) doar atunci când li se face o atribuire "
"*pentru prima oară*. De exemplu, dacă ``x`` este instanța lui "
":class:`!ClasaMea` creată mai sus, atunci următorul fragment de cod va "
"produce afișarea lui ``16``, fără să lase urme (în starea viitoarea a "
"lui ``x``)::"

#: ../../tutorial/classes.rst:334
msgid ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"
msgstr ""
"x.contor = 1\n"
"while x.contor < 10:\n"
"    x.contor = x.contor * 2\n"
"print(x.contor)\n"
"del x.contor"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is"
" a function that \"belongs to\" an object."
msgstr ""
"Celălalt fel de referențiere de atribute de care dispune instanța este "
"*metoda*. O metodă este o funcție care \"îi aparține\" unui obiect."

#: ../../tutorial/classes.rst:345
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is"
" not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Numele valide de metode ale unui obiect instanță depind de clasa acestui "
"obiect instanță. Prin definiție, toate atributele unei clase care sunt "
"obiecte funcție definesc metodele corespunzătoare (omonime) ale instanțelor "
"clasei. Așa că, în exemplul nostru, ``x.f`` este o referire validă la o "
"metodă, deoarece ``ClasaMea.f`` este funcție, pe când ``x.i`` nu este "
"validă ca referire la vreo metodă pentru că ``ClasaMea.i`` nu este "
"funcție. Atenție, ``x.f`` nu este același lucru cu ``ClasaMea.f`` --- "
"primul este un *obiect metodă*, nu un obiect funcție."

#: ../../tutorial/classes.rst:356
msgid "Method Objects"
msgstr "Obiectele metodă"

#: ../../tutorial/classes.rst:358
msgid "Usually, a method is called right after it is bound::"
msgstr ""
"Adesea, o metodă va fi apelată de îndată ce a fost legată (de un anumit "
"obiect)::"

#: ../../tutorial/classes.rst:360
msgid "x.f()"
msgstr "x.f()"

#: ../../tutorial/classes.rst:362
msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: "
"``x.f`` is a method object, and can be stored away and called at a later "
"time.  For example::"
msgstr ""
"În exemplul cu :class:`!ClasaMea`, un atare apel va returna șirul de "
"caractere ``'salutare, lume'``. Pe de altă parte, nu este nevoie să "
"apelăm metodele imediat: cum ``x.f`` este un obiect metodă, el poate fi "
"stocat undeva și apelat la momentul dorit. De exemplu::"

#: ../../tutorial/classes.rst:366
msgid ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"
msgstr ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"

#: ../../tutorial/classes.rst:370
msgid "will continue to print ``hello world`` until the end of time."
msgstr ""
"va afișa ``salutare, lume`` fără să se mai oprească din a da binețe."

#: ../../tutorial/classes.rst:372
msgid ""
"What exactly happens when a method is called?  You may have noticed that "
"``x.f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires"
" an argument is called without any --- even if the argument isn't "
"actually used..."
msgstr ""
"Ce se întâmplă, cu adevărat, atunci când se apelează o metodă? Probabil că "
"ați remarcat faptul că ``x.f()`` a fost apelat, în codul de mai sus, fără "
"să i se dea niciun argument, chiar dacă definiția lui :meth:`!f` specifica "
"un anume argument. Oare ce s-a întâmplat cu acest argument? Doar știm că "
"Python-ul va lansa o excepție atunci când vreo funcție care cerere argument "
"este apelată fără niciun argument --- chiar dacă argumentul nici măcar nu "
"urmează să fie folosit..."

#: ../../tutorial/classes.rst:378
msgid ""
"Actually, you may have guessed the answer: the special thing about "
"methods is that the instance object is passed as the first argument of "
"the function.  In our example, the call ``x.f()`` is exactly equivalent "
"to ``MyClass.f(x)``.  In general, calling a method with a list of *n* "
"arguments is equivalent to calling the corresponding function with an "
"argument list that is created by inserting the method's instance object "
"before the first argument."
msgstr ""
"Păi, se prea poate să fi ghicit, deja, răspunsul: un lucru special "
"privind metodele este acela că obiectul instanță îi este transmis "
"metodei ca *prim argument* al său. În exemplul nostru, apelul ``x.f()`` "
"este absolut echivalent cu ``ClasaMea.f(x)``. Practic, a apela o "
"metodă cu o listă de *n* argumente este totuna cu a apela funcția "
"corespondentă a acestei metode cu o listă de argumente formată prin "
"inserarea obiectului instanță (de care *aparține* metoda) înaintea "
"primului din cele *n* argumente."

#: ../../tutorial/classes.rst:385
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method"
" object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument "
"list, and the function object is called with this new argument list."
msgstr ""
"În general, metodele funcționează după cum urmează. Atunci când un "
"atribut non-dată este referențiat, va fi căutată instanța clasei (sale). "
"Dacă numele (atributului) denotă un atribut valid al clasei iar acest "
"atribut este un obiect funcție, atunci referirile (referințele) respective, "
"atât la obiectul instanță cât și la obiectul funcție, vor fi împachetate "
"într-un obiect metodă. Dacă obiectul metodă este apelat cu o listă de "
"argumente, atunci o nouă listă de argumente va fi construită din obiectul "
"instanță și din elementele listei de argumente în cauză, obiectul funcție "
"corespunzător fiind apelat cu această (nou formată) listă de argumente."

#: ../../tutorial/classes.rst:398
msgid "Class and Instance Variables"
msgstr "Variabile de clasă și variabile de instanță"

#: ../../tutorial/classes.rst:400
msgid ""
"Generally speaking, instance variables are for data unique to each "
"instance and class variables are for attributes and methods shared by all"
" instances of the class::"
msgstr ""
"În jargon POO, variabilele de instanță se referă la datele care îi sunt "
"unice fiecărei instanțe, respectiv variabilele de clasă se referă la "
"atributele și metodele comune tuturor instanțelor clasei respective::"

#: ../../tutorial/classes.rst:404
msgid ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"
msgstr ""
"class Câine:\n"
"\n"
"    genul = 'canis'             # variabilă de clasă comună tuturor\n"
"                                # instanțelor\n"
"\n"
"    def __init__(self, numele):\n"
"        self.numele = numele    # variabilă de instanță, unică fiecărei\n"
"                                # instanțe\n"
"\n"
">>> d = Câine('Fido')\n"
">>> e = Câine('Amicu\'')\n"
">>> d.genul                     # comun tuturor câinilor\n"
"'canis'\n"
">>> e.genul                     # comun tuturor câinilor\n"
"'canis'\n"
">>> d.numele                    # doar al lui d\n"
"'Fido'\n"
">>> e.numele                    # doar al lui e\n"
"\"Amicu'\""

#: ../../tutorial/classes.rst:422
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly "
"surprising effects with involving :term:`mutable` objects such as lists "
"and dictionaries. For example, the *tricks* list in the following code "
"should not be used as a class variable because just a single list would "
"be shared by all *Dog* instances::"
msgstr ""
"Precum spuneam în :ref:`tut-object`, organizarea datelor puse în comun "
"(comune tuturor instanțelor unei clase; sau *partajate* de către toate "
"instanțele unei clase; de la englezescul *shared*) poate produce efecte "
"surprinzătoare dacă folosim la o atare acțiune obiecte :term:`mutable`, "
"precum listele ori dicționarele de date. De exemplu, lista *trucuri* din "
"codul de mai jos n-ar fi trebuit întrebuințată pe post de variabilă de "
"clasă și aceasta pentru că va exista o singură listă ce va fi folosită "
"*la comun* de către toate instanțele *Câine*::"

#: ../../tutorial/classes.rst:428
msgid ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"
msgstr ""
"class Câine:\n"
"\n"
"    trucuri = []            # folosită din greșeală ca variabilă de clasă\n"
"\n"
"    def __init__(self, numele):\n"
"        self.numele = numele\n"
"\n"
"    def adauga_trucul(self, trucul):\n"
"        self.trucuri.append(trucul)\n"
"\n"
">>> d = Câine('Fido')\n"
">>> e = Câine('Amicu\'')\n"
">>> d.adaugă_trucul('rostogol')\n"
">>> e.adaugă_trucul('mort')\n"
">>> d.trucuri               # folosință la comun neașteptată\n"
"['rostogol', 'mort']"

#: ../../tutorial/classes.rst:445
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"O proiectare corectă a clasei ar trebui să folosescă, în locul unei "
"variabile de clasă, o variabilă de instanță::"

#: ../../tutorial/classes.rst:447
msgid ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"
msgstr ""
"class Câine:\n"
"\n"
"    def __init__(self, numele):\n"
"        self.numele = numele\n"
"        self.trucuri = []    # creează câte o listă goală\n"
"                             # pentru fiecare câine\n"
"\n"
"    def adaugă_trucul(self, trucul):\n"
"        self.trucuri.append(trucul)\n"
"\n"
">>> d = Câine('Fido')\n"
">>> e = Câine('Amicu\'')\n"
">>> d.adaugă_trucul('rostogol')\n"
">>> e.adaugă_trucul('mort')\n"
">>> d.trucuri\n"
"['rostogol']\n"
">>> e.trucuri\n"
"['mort']"

#: ../../tutorial/classes.rst:469
msgid "Random Remarks"
msgstr "Observații diverse"

#: ../../tutorial/classes.rst:473
msgid ""
"If the same attribute name occurs in both an instance and in a class, "
"then attribute lookup prioritizes the instance::"
msgstr ""
"Dacă același nume de atribut va apărea și într-o instanță și într-o "
"clasă, la găsirea atributului i se va da prioritate instanței::"

#: ../../tutorial/classes.rst:476
msgid ""
">>> class Warehouse:\n"
"...    purpose = 'storage'\n"
"...    region = 'west'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"storage west\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'east'\n"
">>> print(w2.purpose, w2.region)\n"
"storage east"
msgstr ""
">>> class Depozitul:\n"
"...    scopul = 'înmagazinare'\n"
"...    regiunea = 'vestică'\n"
"...\n"
">>> d1 = Depozitul()\n"
">>> print(d1.scopul, d1.regiunea)\n"
"înmagazinare vestică\n"
">>> d2 = Depozitul()\n"
">>> d2.regiunea = 'estică'\n"
">>> print(d2.scopul, d2.regiunea)\n"
"înmagazinare estică"

#: ../../tutorial/classes.rst:488
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users"
" (\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On"
" the other hand, the Python implementation, written in C, can completely "
"hide implementation details and control access to an object if necessary;"
" this can be used by extensions to Python written in C.)"
msgstr ""
"Atributele de date pot fi referențiate atât de metode cât și de "
"utilizatorii obișnuiți (\"clienții\") ai obiectului (având respectivele "
"atribute). Cu alte cuvinte, clasele sunt inutilizabile la implementarea "
"unor tipuri de *date abstracte* pure. Practic, nimic din Python nu ne poate "
"ajuta să asigurăm *ascunderea datelor* --- totul se bazează pe o simplă "
"convenție. (Pe de altă parte, implementarea de față a Python-ului, scrisă "
"în C, poate să mascheze în totalitate detaliile de implementare, respectiv "
"să controleze accesul la un anumit obiect, atunci când este nevoie de așa "
"ceva; o asemenea capacitate poate fi întrebuințată de diversele extensii "
"ale Python-ului scrise în C.)"

#: ../../tutorial/classes.rst:496
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data "
"attributes.  Note that clients may add data attributes of their own to an"
" instance object without affecting the validity of the methods, as long "
"as name conflicts are avoided --- again, a naming convention can save a "
"lot of headaches here."
msgstr ""
"Clienții trebuie să folosească atributele de date cu grijă --- căci ei "
"pot strica *invarianții* păstrați de metode dacă își vor pune amprenta "
"pe atributele de date ale acestora. Nu uitați că clienții îi pot adăuga "
"atribute după bunul lor plac unui obiect instanță fără ca prin aceasta să "
"le afecteze validitatea metodelor, atâta timp cât se evită conflictele de "
"nume --- și aici, întrebuințarea unei convenții de nume ne poate scăpa de "
"o grămadă de bătăi de cap."

#: ../../tutorial/classes.rst:502
msgid ""
"There is no shorthand for referencing data attributes (or other methods!)"
" from within methods.  I find that this actually increases the "
"readability of methods: there is no chance of confusing local variables "
"and instance variables when glancing through a method."
msgstr ""
"Nu ni se pune la dispoziție nicio scurtătură (și nici alte tehnici!) atunci "
"când referențiem atribute de date din interiorul unei metode. Trebuie spus "
"că o astfel de caracteristică a Python-ului crește lizibilitatea codului "
"oricărei metode: deoarece nu avem nicio șansă să confundăm variabilele "
"locale cu variabilele de instanță atunci când ne aruncăm privirea peste "
"instrucțiunile dintr-o metodă."

#: ../../tutorial/classes.rst:507
msgid ""
"Often, the first argument of a method is called ``self``.  This is "
"nothing more than a convention: the name ``self`` has absolutely no "
"special meaning to Python.  Note, however, that by not following the "
"convention your code may be less readable to other Python programmers, "
"and it is also conceivable that a *class browser* program might be "
"written that relies upon such a convention."
msgstr ""
"Adeseori, primul argument al unei metode este numit ``self``. Aceasta nu "
"este decât o convenție: numele ``self`` nu posedă nicio semnificație "
"aparte pentru Python. Remarcați, însă, că dacă nu vă veți face obiceiul "
"de a-l folosi, atunci s-ar putea întâmpla ca programul dumneavoastră să "
"le provoace dificultăți la lectură altor programatori în Python, după "
"cum s-ar putea și să aveți greutăți cu vreo aplicație *cititor de clase* "
"care se bazează tocmai pe această convenție de nume."

#: ../../tutorial/classes.rst:513
msgid ""
"Any function object that is a class attribute defines a method for "
"instances of that class.  It is not necessary that the function "
"definition is textually enclosed in the class definition: assigning a "
"function object to a local variable in the class is also ok.  For "
"example::"
msgstr ""
"Orice obiect funcție care este (și) atribut de clasă definește o metodă "
"pentru instanțele clasei în cauză. Nu este obligatoriu ca definiția "
"funcției respective să fie literalmente parte din definiția clasei: este "
"suficient să îi asignăm unei variabile locale din clasă un obiect "
"funcție. De exemplu::"

#: ../../tutorial/classes.rst:518
msgid ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"
msgstr ""
"# Funcție definită în afara clasei\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'salutare, lume'\n"
"\n"
"    h = g"

#: ../../tutorial/classes.rst:530
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  "
"Note that this practice usually only serves to confuse the reader of a "
"program."
msgstr ""
"Aici, ``f``, ``g`` și ``h`` îi sunt cu toatele atribute clasei :class:`!C` "
"și se referă la obiecte funcție, din care motiv ele le vor fi metode "
"tuturor instanțelor lui :class:`!C` --- ``h`` nefiind nimic altceva decât "
"``g``. Atenție la faptul că o astfel de abordare va reuși doar să-i "
"provoace confuzii vreunui cititor al programului dumneavoastră."

#: ../../tutorial/classes.rst:535
msgid ""
"Methods may call other methods by using method attributes of the ``self``"
" argument::"
msgstr ""
"Metodele pot apela alte metode folosind atributele de metodă ale "
"argumentului ``self``::"

#: ../../tutorial/classes.rst:538
msgid ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"
msgstr ""
"class Punga:\n"
"    def __init__(self):\n"
"        self.datele = []\n"
"\n"
"    def adaugă(self, x):\n"
"        self.datele.append(x)\n"
"\n"
"    def adaugă_dublu(self, x):\n"
"        self.adaugă(x)\n"
"        self.adaugă(x)"

#: ../../tutorial/classes.rst:549
msgid ""
"Methods may reference global names in the same way as ordinary functions."
"  The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely"
" encounters a good reason for using global data in a method, there are "
"many legitimate uses of the global scope: for one thing, functions and "
"modules imported into the global scope can be used by methods, as well as"
" functions and classes defined in it.  Usually, the class containing the "
"method is itself defined in this global scope, and in the next section "
"we'll find some good reasons why a method would want to reference its own"
" class."
msgstr ""
"Metodele se pot referi la numele globale în același fel ca funcțiile "
"obișnuite. Domeniul de valabilitate global care i se asociază unei "
"metode este chiar modulul care conține definiția metodei. (O clasă, ca "
"atare, nu se folosește niciodată pe post de domeniu de valabilitate "
"global.) Chiar dacă nu vom avea decât arareori motive serioase să "
"întrebuințăm date globale în vreo metodă, există numeroase utilizări "
"legitime ale domeniului de valabilitate global: cum ar fi, funcțiile "
"și modulele importate în domeniul de valabilitate global pot fi folosite "
"atât de către metode cât și de către funcțiile ori clasele care au fost "
"definite în el. În mod obișnuit, clasa care conține o anumită metodă este "
"ea însăși definită în acest domeniu de valabilitate global, iar noi vom "
"face cunoștință în secțiunea următoare cu mai multe motive întemeiate "
"ca o metodă oarecare să dorească să se refere la propria sa clasă."

#: ../../tutorial/classes.rst:559
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Orice valoare este, în sine, un obiect și dispune, ca atare, de o "
"*clasă* (aceasta mai numindu-se și *tipul* valorii). Clasa respectivă "
"este stocată drept ``obiectul_nostru.__class__``."

#: ../../tutorial/classes.rst:566
msgid "Inheritance"
msgstr "Moștenirea"

#: ../../tutorial/classes.rst:568
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class "
"definition looks like this::"
msgstr ""
"Așa cum se înțelege de la sine, o caracteristică a indiferent cărui limbaj "
"de programare n-ar putea fi socotită \"de clasă\" dacă nu le-ar face față "
"cum se cuvine *moștenirilor* (dificultăților...). În cazul Python-ului, "
"sintaxa pentru definirea unei clase *derivate* (dintr-o clasă *de bază*) "
"arată după cum urmează::"

#: ../../tutorial/classes.rst:572
msgid ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class NumeleClaseiDerivate(NumeleClaseiDeBază):\n"
"    <instrucțiunea-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <instrucțiunea-N>"

#: ../../tutorial/classes.rst:579
msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace "
"accessible from the scope containing the derived class definition.  In "
"place of a base class name, other arbitrary expressions are also allowed."
"  This can be useful, for example, when the base class is defined in "
"another module::"
msgstr ""
"Numele :class:`!NumeleClaseiDeBază` trebuie să fie definit într-un spațiu "
"de nume ce poate fi accesat din domeniul de valabilitate în care a fost "
"introdusă definiția clasei derivate despre care discutăm. Sunt permise, în "
"locul unui nume de clasă cu rolul de clasă de bază, (și) expresii oarecare. "
"O astfel de flexibilitate în definiții se va dovedi folositoare atunci "
"când, de exemplu, clasa de bază este situată în alt modul::"

#: ../../tutorial/classes.rst:585
msgid "class DerivedClassName(modname.BaseClassName):"
msgstr "class NumeleClaseiDerivate(nume_de_modul.NumeleClaseiDeBază):"

#: ../../tutorial/classes.rst:587
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is "
"remembered.  This is used for resolving attribute references: if a "
"requested attribute is not found in the class, the search proceeds to "
"look in the base class.  This rule is applied recursively if the base "
"class itself is derived from some other class."
msgstr ""
"Execuția (codului) unei definiții de clasă derivată se realizează în "
"același fel cu execuția (codului) unei clase de bază. Atunci când este "
"construit obiectul clasă (derivată), interpretorul *își amintește* (și) de "
"clasa de bază. Această proprietate se întrebuințează la rezolvarea "
"referințelor de atribute: dacă vreun atribut căutat nu se găsește în codul "
"clasei (derivate), căutarea sa va trece la codul clasei de bază. O atare "
"regulă va fi aplicată *recursiv* dacă clasa de bază se dovedește a fi, la "
"rândul său, derivată din altă clasă."

#: ../../tutorial/classes.rst:593
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the"
" method reference is valid if this yields a function object."
msgstr ""
"Nimic deosebit nu se va întâmpla la instanțierea claselor derivate: ca și "
"până acum, ``NumeleClaseiDerivate()`` va crea o instanță (nouă) a clasei "
"respective. Referințele la metode sunt rezolvate astfel: se caută atributul "
"de clasă corespunzător, coborând, la nevoie, pe *lanțul* ("
"`dependențelor <https://en.wikipedia.org/wiki/Dependency_hell>`_"
") care duce până la clasele de bază, apoi, odată găsit numele, referința "
"metodei este considerată validă dacă ea întoarce un obiect funcție."

#: ../../tutorial/classes.rst:599
msgid ""
"Derived classes may override methods of their base classes.  Because "
"methods have no special privileges when calling other methods of the same"
" object, a method of a base class that calls another method defined in "
"the same base class may end up calling a method of a derived class that "
"overrides it.  (For C++ programmers: all methods in Python are "
"effectively ``virtual``.)"
msgstr ""
"Clasele derivate au dreptul să-și suprascrie metodele (moștenite) de la "
"clasele de bază. Deoarece metodele nu beneficiază de privilegii anume "
"atunci când apelează metode ale aceluiași obiect, o metodă aparținând unei "
"clase de bază care apelează altă metodă definită în aceeași clasă de "
"bază poate avea surpriza că a apelat, de fapt, metoda unei clase derivate "
"care a suprascris metoda (teoretic) apelată. (Pentru programatorii în C++: "
"toate metodele din Python sunt efectiv ``virtuale``.)"

#: ../../tutorial/classes.rst:605
msgid ""
"An overriding method in a derived class may in fact want to extend rather"
" than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call "
"``BaseClassName.methodname(self, arguments)``.  This is occasionally "
"useful to clients as well.  (Note that this only works if the base class "
"is accessible as ``BaseClassName`` in the global scope.)"
msgstr ""
"O metodă suprascrisă într-o clasă derivată dorește, cel mai adesea, să "
"extindă și nu să înlocuiască pur și simplu metoda omonimă din clasa de "
"bază. Dispunem de un procedeu necomplicat pentru a apela în mod direct "
"metoda unei clase de bază: apelați, de-a dreptul, "
"``NumeleClaseiDeBază.numele_metodei(self, restul_argumentelor)``. O atare "
"proprietate le folosește și clienților. (Țineți seama de faptul că ea "
"funcționează doar atunci când clasa de bază este accesibilă sub denumirea "
"de ``NumeleClaseiDeBază`` în domeniul de valabilitate global.)"

#: ../../tutorial/classes.rst:612
msgid "Python has two built-in functions that work with inheritance:"
msgstr ""
"Python-ul are două funcții predefinite care conlucrează cu moștenirea:"

#: ../../tutorial/classes.rst:614
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, "
"int)`` will be ``True`` only if ``obj.__class__`` is :class:`int` or some"
" class derived from :class:`int`."
msgstr ""
"Utilizați :func:`isinstance` pentru a verifica tipul unei instanțe: "
"``isinstance(obiectul_în_cauză, int)`` va întoarce ``True`` dacă și numai "
"dacă ``obiectul_în_cauză.__class__`` este fie :class:`int` fie altă clasă "
"derivată din :class:`int`."

#: ../../tutorial/classes.rst:618
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, "
"int)`` is ``True`` since :class:`bool` is a subclass of :class:`int`.  "
"However, ``issubclass(float, int)`` is ``False`` since :class:`float` is "
"not a subclass of :class:`int`."
msgstr ""
"Întrebuințați :func:`issubclass` pentru a testa moștenirea unei clase: "
"``issubclass(bool, int)`` va returna ``True`` pentru că :class:`bool` este "
"o *subclasă* (adică, o *moștenitoare*; sau o *urmașă*) a lui :class:`int`. "
"În schimb, ``issubclass(float, int)`` va întoarce ``False`` dat fiind că "
":class:`float` nu îi este subclasă lui :class:`int`."

#: ../../tutorial/classes.rst:628
msgid "Multiple Inheritance"
msgstr "Moștenirea multiplă"

#: ../../tutorial/classes.rst:630
msgid ""
"Python supports a form of multiple inheritance as well.  A class "
"definition with multiple base classes looks like this::"
msgstr ""
"Python-ul permite și o anumită formă de "
"`moștenire multiplă <https://isocpp.org/wiki/faq/multiple-inheritance>`_. "
"Definiția unei clase care moștenește *mai multe* clase de bază arată în "
"felul următor::"

#: ../../tutorial/classes.rst:633
msgid ""
"class DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class NumeleClaseiDerivate(ClasaDeBază1, ClasaDeBază2, ClasaDeBază3):\n"
"    <instrucțiunea-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <instrucțiunea-N>"

#: ../../tutorial/classes.rst:640
msgid ""
"For most purposes, in the simplest cases, you can think of the search for"
" attributes inherited from a parent class as depth-first, left-to-right, "
"not searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in "
":class:`!DerivedClassName`, it is searched for in :class:`!Base1`, then "
"(recursively) in the base classes of :class:`!Base1`, and if it was not "
"found there, it was searched for in :class:`!Base2`, and so on."
msgstr ""
"În cele mai multe dintre situațiile obișnuite (a se citi *simple*), ne "
"putem imagina *căutarea* unui atribut moștenit de la o clasă părinte ca "
"efectuându-se `în adâncime "
"<https://en.wikipedia.org/wiki/Depth-first_search>`_ "
"(de la englezescul, în jargon informatic, *depth-first*), *de la stânga "
"la dreapta*, fără să se caute de două ori în aceeași clasă în cazul unor "
"*suprapuneri* în `ierarhie "
"<https://en.wikipedia.org/wiki/Class_hierarchy>`_ (adică, în ansamblul "
"claselor legate între ele prin mecanismele moștenirii). Astfel, dacă "
"atributul căutat nu este găsit în :class:`!NumeleClaseiDerivate`, el "
"va fi căutat (mai întâi) în clasa de bază :class:`!ClasaDeBază1`, apoi "
"(recursiv) în clasele de bază ale lui :class:`!ClasaDeBază1`, după care, "
"dacă nu a fost găsit încă, va fi căutat în :class:`!ClasaDeBază2` șamd."

#: ../../tutorial/classes.rst:647
msgid ""
"In fact, it is slightly more complex than that; the method resolution "
"order changes dynamically to support cooperative calls to :func:`super`."
"  This approach is known in some other multiple-inheritance languages as "
"call-next-method and is more powerful than the super call found in "
"single-inheritance languages."
msgstr ""
"În realitate, procedurile sunt oarecum mai complexe decât schița "
"anterioară; ordinea (căutărilor) în procedura de *rezolvare* a unei metode "
"se schimbă în mod dinamic pentru a permite apeluri cooperatiste ale lui "
":func:`super`. O atare abordare este cunoscută în vocabularul unor limbaje "
"de programare care implementează moștenirea multiplă drept *apelul "
"metodei următoare* și dovedește mai multă eficacitate decât *apelul lui "
"super* utilizat în limbajele de programare care întrebuințează doar "
"moștenirea simplă."

#: ../../tutorial/classes.rst:653
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the "
"parent classes can be accessed through multiple paths from the bottommost"
" class).  For example, all classes inherit from :class:`object`, so any "
"case of multiple inheritance provides more than one path to reach "
":class:`object`.  To keep the base classes from being accessed more than "
"once, the dynamic algorithm linearizes the search order in a way that "
"preserves the left-to-right ordering specified in each class, that calls "
"each parent only once, and that is monotonic (meaning that a class can be"
" subclassed without affecting the precedence order of its parents). Taken"
" together, these properties make it possible to design reliable and "
"extensible classes with multiple inheritance.  For more detail, see "
":ref:`python_2.3_mro`."
msgstr ""
"Ordonarea dinamică este necesară pentru că în toate cazurile de moștenire "
"multiplă survin relațiile în `formă de diamant "
"<https://en.wikipedia.org/wiki/Multiple_inheritance>`_ dintre clase (în "
"care cel puțin una din clasele părinte va putea fi accesată de către măcar "
"o clasă urmaș prin *cel puțin două drumuri* care să plece din clasa "
"părinte, să parcurgă un subset de muchii ale arborelui moștenirii și să se "
"încheie la clasa urmaș respectivă). De exemplu, toate clasele moștenesc "
"clasa :class:`object`, din care motiv, în cazul unei moșteniri multiple, "
"vor exista mai multe căi de acces la :class:`object`. Pentru a împiedica "
"accesul la indiferent care clasă de bază pe mai multe căi (deci *de mai "
"multe ori* într-o singură căutare), algoritmul dinamic de căutare va "
"liniariza ordinea acesteia în așa fel încât să fie păstrată ordonarea de "
"la stânga la dreapta specificată pentru fiecare clasă, ordonare care "
"apelează fiecare părinte o singură dată și care este *monotonă* (adică, "
"în raport cu care o clasă poate fi făcută subclasă a cuiva fără să fie "
"afectată ordonarea realizată până la momentul respectiv a *strămoșilor* "
"ei). Luate împreună, aceste particularități ale Python-ului ne permit să "
"proiectăm ierarhii de clase stabile și ușor de extins în care să avem "
"moștenire multiplă. Pentru mai multe detalii, a se vedea "
":ref:`python_2.3_mro`."

#: ../../tutorial/classes.rst:670
msgid "Private Variables"
msgstr "Variabile private"

#: ../../tutorial/classes.rst:672
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside"
" an object don't exist in Python.  However, there is a convention that is"
" followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it "
"is a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"În Python nu există variabile de instanță \"private\", adică variabile "
"care să nu poată fi accesate decât din interiorul instanței respective. Cu "
"toate acestea, dispunem de o convenție respectată de aproape întreg codul "
"Python: orice nume prefixat de o *bară jos* (adică, de o *liniuță de "
"subliniere*; precum în ``_șuncă``) trebuie socotit drept parte non-publică "
"a API-ului (indiferent dacă este vorba de o funcție, de o metodă ori de o "
"dată membru). Numele respectiv trebuie, așadar, tratat cu grija pe care "
"o avem pentru un detaliu de implementare, despre care știm că s-ar putea "
"schimba oricând, fără să fim anunțați."

#: ../../tutorial/classes.rst:682
msgid ""
"Since there is a valid use-case for class-private members (namely to "
"avoid name clashes of names with names defined by subclasses), there is "
"limited support for such a mechanism, called :dfn:`name mangling`.  Any "
"identifier of the form ``__spam`` (at least two leading underscores, at "
"most one trailing underscore) is textually replaced with "
"``_classname__spam``, where ``classname`` is the current class name with "
"leading underscore(s) stripped.  This mangling is done without regard to "
"the syntactic position of the identifier, as long as it occurs within the"
" definition of a class."
msgstr ""
"Deoarece există, în practica POO, un caz de întrebuințare valid pentru "
"membrii privați ai unei clase (mai precis, procedeul prin care să evităm "
"*conflictele de nume* cu numele definite de clasele urmaș), avem la "
"îndemână în Python un suport restrâns pentru un atare mecanism, denumit "
":dfn:`transformare de nume` (de la englezescul *name mangling*). Astfel, "
"orice identificator de forma ``__șuncă`` (cel puțin două bare jos pe post "
"de prefixe și cel mult o bară jos pe post de sufix) va fi înlocuit în "
"textul programului cu ``_numeleclasei__șuncă``, unde ``numeleclasei`` "
"desemnează numele de clasă curent, cu prefixul ori prefixele eliminat(e). "
"Această transformare de nume se va realiza indiferent de poziția sintactică "
"a identificatorului, atâta timp când aceasta se găsește în interiorul unei "
"definiții de clasă."

#: ../../tutorial/classes.rst:693
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` "
"for details and special cases."
msgstr ""
":ref:`Specificațiile transformărilor de nume private "
"<private-name-mangling>` pentru detalii și cazuri speciale."

#: ../../tutorial/classes.rst:696
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"Transformarea de nume este utilă la a le permite subclaselor să suprascrie "
"diverse metode fără să strice apelurile de metode intra-clasă. Ca exemplu::"

#: ../../tutorial/classes.rst:699
msgid ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"
msgstr ""
"class Mapare:\n"
"    def __init__(self, iterabilul):\n"
"        self.lista_de_itemi = []\n"
"        self.__actualizează(iterabilul)\n"
"\n"
"    def actualizează(self, iterabilul):\n"
"        for itemul in iterabilul:\n"
"            self.lista_de_itemi.append(itemul)\n"
"\n"
"    __actualizează = actualizează   # copie privată a metodei\n"
"                                    # actualizează() originale\n"
"\n"
"class SubclasaLuiMapare(Mapare):\n"
"\n"
"    def actualizează(self, cheile, valorile):\n"
"        # îi oferă o nouă signatură lui actualizează()\n"
"        # fără să-l strice pe __init__()\n"
"        for itemul in zip(cheile, valorile):\n"
"            self.lista_de_itemi.append(itemul)"

#: ../../tutorial/classes.rst:718
msgid ""
"The above example would work even if ``MappingSubclass`` were to "
"introduce a ``__update`` identifier since it is replaced with "
"``_Mapping__update`` in the ``Mapping`` class  and "
"``_MappingSubclass__update`` in the ``MappingSubclass`` class "
"respectively."
msgstr ""
"Exemplul de deasupra va funcționa chiar și în cazul când în "
"``SubclasaLuiMapare`` am introduce un identificator ``__actualizează`` "
"și aceasta pentru că identificatorul în cauză va fi înlocuit cu "
"``_Mapare__actualizează`` în clasa ``Mapare``, respectiv cu "
"``_SubclasaLuiMapare__actualizează`` în clasa ``SubclasaLuiMapare``."

#: ../../tutorial/classes.rst:723
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in "
"the debugger."
msgstr ""
"Nu uitați că regulile de transformare ale numelor au fost proiectate mai "
"ales pentru a ne feri de accidente; este posibil, în pofida lor, să "
"accesați, respectiv să modificați orice variabilă socotită drept "
"*privată*. O asemenea libertate ne poate fi de folos în circumstanțe "
"deosebite, precum cele ale întrebuințării unui depanator de programe (de la "
"englezescul *debugger*)."

#: ../../tutorial/classes.rst:727
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the"
" classname of the invoking class to be the current class; this is similar"
" to the effect of the ``global`` statement, the effect of which is "
"likewise restricted to code that is byte-compiled together.  The same "
"restriction applies to ``getattr()``, ``setattr()`` and ``delattr()``, as"
" well as when referencing ``__dict__`` directly."
msgstr ""
"Țineți seama (și) de faptul că, indiferent de cod îi transmiteți fie lui "
"``exec()`` fie lui ``eval()``, acesta nu va considera numele de clasă al "
"clasei care a făcut invocarea (uneia din cele două funcții) drept numele "
"clasei curente; o atare situație seamănă cu efectul produs de execuția "
"instrucțiunii ``global``, efect care este restrâns doar la codul compilat "
"într-un singur fragment de cod-de-octeți. Aceeași restricție le privește "
"și pe ``getattr()``, ``setattr()`` și ``delattr()``, precum și pe orice "
"referențiere directă a lui ``__dict__``."

#: ../../tutorial/classes.rst:738
msgid "Odds and Ends"
msgstr "Șurubărie"

#: ../../tutorial/classes.rst:740
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal "
"\"record\" or C \"struct\", bundling together a few named data items. The"
" idiomatic approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"Ne servește uneori să avem la îndemână un tip de date asemănător celui "
"numit \"record\" în Pascal, respectiv lui \"struct\" din C, tip care să "
"pună laolaltă mai mulți itemi de date cu denumiri (individuale). Procedeul "
"idiomatic pentru așa ceva (în Python) este dat de :mod:`dataclasses`::"

#: ../../tutorial/classes.rst:744
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Angajatul:\n"
"    numele: str\n"
"    departamentul: str\n"
"    salariul: int"

#: ../../tutorial/classes.rst:754
msgid ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"
msgstr ""
">>> popescu = Angajatul('popescu', 'sala de calculatoare', 1000)\n"
">>> popescu.departamentul\n"
"'sala de calculatoare'\n"
">>> popescu.salariul\n"
"1000"

#: ../../tutorial/classes.rst:760
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data "
"from a file object, you can define a class with methods "
":meth:`~io.TextIOBase.read` and :meth:`~io.TextIOBase.readline` that get "
"the data from a string buffer instead, and pass it as an argument."
msgstr ""
"Unui fragment de program Python care se așteaptă să primească un anumit "
"tip de date abstracte îi putem transmite, de cele mai multe ori, pe post "
"de înlocuitor o clasă care *emulează* metodele tipului de date respectiv. "
"De exemplu, admițând că dispunem de o funcție care formatează diverse "
"date preluate dintr-un obiect fișier, putem defini mai întâi o clasă căreia "
"să-i aparțină metodele :meth:`~io.TextIOBase.read` și "
":meth:`~io.TextIOBase.readline`, metode capabile să extragă datele dintr-o "
"memorie-tampon (de la englezescul *buffer*) dedicată stocării (temporare "
"a) șirurilor de caractere, după care îi putem transmite funcției de "
"formatare această clasă în calitate de argument."

#: ../../tutorial/classes.rst:772
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: "
":attr:`m.__self__ <method.__self__>` is the instance object with the "
"method :meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the "
":ref:`function object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Obiectele metodă de instanță <instance-methods>` posedă, și ele, "
"atribute: :attr:`metoda.__self__ <method.__self__>` este obiectul instanță "
"căruia îi aparține metoda :meth:`!metoda`, respectiv "
":attr:`metoda.__func__ <method.__func__>` este "
":ref:`obiectul funcție <user-defined-funcs>` care îi corespunde "
"metodei în cauză (adică, lui :meth:`!metoda`)."

#: ../../tutorial/classes.rst:782
msgid "Iterators"
msgstr "Iteratori"

#: ../../tutorial/classes.rst:784
msgid ""
"By now you have probably noticed that most container objects can be "
"looped over using a :keyword:`for` statement::"
msgstr ""
"Deja ați remarcat, probabil, că majoritatea obiectelor *container* "
"pot fi inspectate în mod iterativ (de la englezescul, în jargon "
"informatic, *loop over*; vom întrebuința și constructele *iterate "
"de-a lungul*, respectiv *iterate în lung*) folosind o instrucțiune de "
"ciclare :keyword:`for`::"

#: ../../tutorial/classes.rst:787
#, python-brace-format
msgid ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"
msgstr ""
"for elementul in [1, 2, 3]:\n"
"    print(elementul)\n"
"for elementul in (1, 2, 3):\n"
"    print(elementul)\n"
"for cheia in {'unu':1, 'doi':2}:\n"
"    print(cheia)\n"
"for cheia in \"123\":\n"
"    print(cheia)\n"
"for rândul in open(\"fișierul_meu_text.txt\"):\n"
"    print(rândul, end='')"

#: ../../tutorial/classes.rst:798
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the "
":keyword:`for` statement calls :func:`iter` on the container object.  The"
" function returns an iterator object that defines the method "
":meth:`~iterator.__next__` which accesses elements in the container one "
"at a time.  When there are no more elements, :meth:`~iterator.__next__` "
"raises a :exc:`StopIteration` exception which tells the :keyword:`!for` "
"loop to terminate.  You can call the :meth:`~iterator.__next__` method "
"using the :func:`next` built-in function; this example shows how it all "
"works::"
msgstr ""
"Acest stil de acces la itemi este clar, concis și convenabil. Utilizarea "
"iteratorilor constituie o practică sistematică, cu caracter unificator, în "
"Python. În culise, instrucțiunea :keyword:`for` face apel la :func:`iter` "
"având drept argument obiectul container. Funcția va întoarce un obiect "
"*iterator*, care definește metoda :meth:`~iterator.__next__`, metodă ce "
"accesează în mod secvențial elementele containerului respectiv. Atunci "
"când nu mai întâlnește niciun item (al containerului), "
":meth:`~iterator.__next__` va lansa o excepție :exc:`StopIteration` pentru "
"a-i spune buclei :keyword:`!for` să se încheie. Puteți apela metoda "
":meth:`~iterator.__next__` cu ajutorul funcției prestabilite :func:`next`; "
"exemplul următor vă dezvăluie cum trebuie procedat::"

#: ../../tutorial/classes.rst:807
msgid ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"
msgstr ""
">>> șirul = 'abc'\n"
">>> iteratorul = iter(șirul)\n"
">>> iteratorul\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(iteratorul)\n"
"'a'\n"
">>> next(iteratorul)\n"
"'b'\n"
">>> next(iteratorul)\n"
"'c'\n"
">>> next(iteratorul)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(iteratorul)\n"
"StopIteration"

#: ../../tutorial/classes.rst:823
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add"
" iterator behavior to your classes.  Define an "
":meth:`~container.__iter__` method which returns an object with a "
":meth:`~iterator.__next__` method.  If the class defines "
":meth:`!__next__`, then :meth:`!__iter__` can just return ``self``::"
msgstr ""
"Le putem acum, dat fiind că tocmai am văzut mecanismul prin care se pune în "
"practică *protocolul* iteratorilor, adăuga un *comportament* de iterator "
"claselor noastre. Este suficient să definim o metodă "
":meth:`~container.__iter__`, care să întoarcă un obiect ce posedă o metodă "
":meth:`~iterator.__next__`. În caz că clasa noastră îl definește ea însăși "
"pe :meth:`!__next__`, metoda :meth:`!__iter__` nu mai are de făcut decât "
"să-l returneze pe ``self`` (apelantului)::"

#: ../../tutorial/classes.rst:828
msgid ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"
msgstr ""
"class ÎntorsulPeDos:\n"
"    \"\"\"Un iterator pentru a itera de-a lungul unei secvențe,\n"
"       în sens invers.\"\"\"\n"
"    def __init__(self, datele):\n"
"        self.datele = datele\n"
"        self.indexul = len(datele)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.indexul == 0:\n"
"            raise StopIteration\n"
"        self.indexul = self.indexul - 1\n"
"        return self.datele[self.indexul]"

#: ../../tutorial/classes.rst:845
msgid ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"
msgstr ""
">>> reversul = ÎntorsulPeDos('arca')\n"
">>> iter(reversul)\n"
"<__main__.ÎntorsulPeDos object at 0x00A1DB50>\n"
">>> for caracterul in reversul:\n"
"...     print(caracterul)\n"
"...\n"
"a\n"
"c\n"
"r\n"
"a"

#: ../../tutorial/classes.rst:860
msgid "Generators"
msgstr "Generatori"

#: ../../tutorial/classes.rst:862
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for "
"creating iterators.  They are written like regular functions but use the "
":keyword:`yield` statement whenever they want to return data.  Each time "
":func:`next` is called on it, the generator resumes where it left off (it"
" remembers all the data values and which statement was last executed).  "
"An example shows that generators can be trivially easy to create::"
msgstr ""
":term:`Generatorii <generator>` sunt o unealtă puternică, ușor de folosit "
"la construcția de iteratori. Codul Python al generatorilor este asemeni "
"celui al unei funcții obișnuite cu excepția faptului că întrebuințează "
"instrucțiunea :keyword:`yield` (în loc de *return*) ori de câte "
"ori trebuie întoarse date (apelantului). De fiecare dată când un generator "
"va fi (re)folosit drept argument al lui :func:`next`, *el își va continua "
"activitatea* (dat fiind că un generator *își amintește* toate valorile "
"datelor precum și ultima instrucție executată de la apelul precedent al "
"lui *next*). Exemplul dat în continuare vă arată că generatorii sunt "
"banal de creat::"

#: ../../tutorial/classes.rst:869
msgid ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"
msgstr ""
"def întoarce_pe_dos(datele):\n"
"    for indexul in range(len(datele)-1, -1, -1):\n"
"        yield datele[indexul]"

#: ../../tutorial/classes.rst:875
msgid ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"
msgstr ""
">>> for caracterul in intoarce_pe_dos('trop'):\n"
"...     print(caracterul)\n"
"...\n"
"p\n"
"o\n"
"r\n"
"t"

#: ../../tutorial/classes.rst:883
msgid ""
"Anything that can be done with generators can also be done with class-"
"based iterators as described in the previous section.  What makes "
"generators so compact is that the :meth:`~iterator.__iter__` and "
":meth:`~generator.__next__` methods are created automatically."
msgstr ""
"Orice poate fi realizat folosind iteratorii bazați (explicit) pe clase, "
"vezi cele prezentate în secțiunea anterioară, poate fi obținut și cu "
"generatori. Ceea ce face codul acestora din urmă atât de compact este "
"faptul că metodele :meth:`~iterator.__iter__` și "
":meth:`~generator.__next__` sunt create automat."

#: ../../tutorial/classes.rst:888
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to "
"write and much more clear than an approach using instance variables like "
"``self.index`` and ``self.data``."
msgstr ""
"Altă trăsătură cheie a generatorilor este aceea că atât variabilele "
"locale cât și starea de la momentul execuției sunt salvate automate între "
"apeluri. Din acest motiv, codul funcției (generator) este mai ușor de "
"scris și mult mai clar în exprimarea ideilor decât ceea ce putem realiza "
"cu o abordare (complicată) în care avem de folosit variabile de instanță "
"precum ``self.indexul`` și ``self.datele``."

#: ../../tutorial/classes.rst:893
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more"
" effort than writing a regular function."
msgstr ""
"În afară de creatul automat de metode și de salvatul stării programului, "
"generatorii au proprietatea că, atunci când își termină iterarea, vor "
"lansa automat o :exc:`StopIteration`. Luate împreună, aceste caracteristici "
"ne permit să construim iteratori cu același efort ca la scrierea codului "
"unei funcții oarecare."

#: ../../tutorial/classes.rst:902
msgid "Generator Expressions"
msgstr "Expresii generator"

#: ../../tutorial/classes.rst:904
msgid ""
"Some simple generators can be coded succinctly as expressions using a "
"syntax similar to list comprehensions but with parentheses instead of "
"square brackets. These expressions are designed for situations where the "
"generator is used right away by an enclosing function.  Generator "
"expressions are more compact but less versatile than full generator "
"definitions and tend to be more memory friendly than equivalent list "
"comprehensions."
msgstr ""
"Generatorii simpli pot fi introduși succint în codul Python ca *expresii* "
"(generator) a căror sintaxă seamănă cu cea de la comprehensiunea listelor, "
"excepție făcând faptul că acolo erau folosite paranteze drepte pe când "
"aici vom întrebuința paranteze rotunde. Astfel de expresii sunt proiectate "
"pentru situații când este nevoie de un generator (simplu) care să fie "
"utilizat de îndată (ce a fost citit de interpretor) de către funcția în "
"codul căreia a fost inserat. Expresiile generator sunt (încă și) mai "
"compacte deși mai puțin versatile decât definițiile complete de generatori, "
"respectiv tind să fie mai prietenoase în privința consumului de memorie "
"decât comprehensiunile de liste corespondente."

#: ../../tutorial/classes.rst:911
msgid "Examples::"
msgstr "Exemple::"

#: ../../tutorial/classes.rst:913
msgid ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"
msgstr ""
">>> sum(i*i for i in range(10))      # sumă de pătrate perfecte\n"
"285\n"
"\n"
">>> vectorul_x = [10, 20, 30]\n"
">>> vectorul_y = [7, 5, 3]\n"
">>> sum(x*y for x,y in\n"
"...     zip(vectorul_x, vectorul_y)) # produs scalar\n"
"260\n"
"\n"
">>> cuvinte_unice = set(cuvântul for rândul in pagina\n"
"...                     for cuvântul in rândul.split())\n"
"\n"
">>> șef_de_promoție = max((studentul.media_generală, studentul.numele)\n"
"...                       for studentul in absolvenți)\n"
"\n"
">>> datele = 'trop'\n"
">>> list(datele[i] for i in range(len(datele)-1, -1, -1))\n"
"['p', 'o', 'r', 't']"

#: ../../tutorial/classes.rst:932
msgid "Footnotes"
msgstr "Note de subsol"

#: ../../tutorial/classes.rst:933
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name ``__dict__`` is an attribute "
"but not a global name. Obviously, using this violates the abstraction of "
"namespace implementation, and should be restricted to things like post-"
"mortem debuggers."
msgstr ""
"Cu o excepție. Obiectele modul au un atribut *secret*, doar-de-citit, numit "
":attr:`~object.__dict__`, atribut care returnează dicționarul de date "
"utilizat la implementarea spațiului de nume al modulului; numele "
"``__dict__`` este atribut, fără a fi (și) un nume global. Categoric, "
"întrebuințarea sa violează caracterul de *abstracțiune* al implementării "
"spațiilor de nume, motiv pentru care ea trebuie rezumată doar la activități "
"precum depanarea post-mortem a programelor Python."

#: ../../tutorial/classes.rst:343
msgid "object"
msgstr "obiect"

#: ../../tutorial/classes.rst:343
msgid "method"
msgstr "metodă"

#: ../../tutorial/classes.rst:679
msgid "name"
msgstr "nume"

#: ../../tutorial/classes.rst:679
msgid "mangling"
msgstr "transformare"

